---
---

:skip-front-matter:

= Machinekit Multicore
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

== History

On 7th February 2017, a body of work called 'multicore' was merged into the main Machinekit repo.

This work was done approximately 2 years earlier by Michael Haberler and Mick Grant. +
Its aim was to make Machinekit HAL operations safe across multiple cores and threads.

HAL was conceived at a time when the default PC model was single core x86. +
It assumed all rt threads were running on a single core and also assumed that it would be running
on a conservative, strictly ordered memory model ie. x86, in relation to HAL object layout.

As hardware developed, multiple cores and caches became the norm, even on small Soc boards. +
Its assumptions about cache architecture could be seen to start to give rise to 'false sharing', +
when different cores, with their own caches, started trying to access the same pin.

An even worse situation existed in a few components, where one component ran several threads and used
non-preemptive scheduling to create a 'shared state sychronisation'.

As soon as one of these threads start running on other cores, with their own scheduling, this rapidly falls apart. +
A lower priority thread can run on another core, when it was assumed it would have to wait for the higher priority 
thread to exit on a single core.

== Multicore solutions

To combat the value consistency problems, atomic operations were used to read and write.  +
An atomic operation is one which is indivisible and runs without interruption in a single step. + 
This prevents race conditions where more than one update is being attempted to a pin or signal.

The operations on pins etc are made via accessor functions, removing the direct memory access used in legacy HAL operations. +
This removes the need for the memory address of the data to be known by the calling function and assumptions about memory
ordering. +
Since the operations are atomic, they can be lock free.

Further measures to achieve synchronisation and data sharing via lock-free data structures, ring buffers and triple buffers were made.

For the full details, see this talk from 2015. +
https://plus.google.com/events/cvhj9r8m2gh0v0kj7ccme36hlpo 

== v2 components

Components which utilise the 'atomic operation via accessors' model, were called version 2 or v2 for short. +
They have v2 inserted before the file extension eg. debouncev2.icomp

In the instantiated components directory src/hal/i_components, there are conventional and v2 versions of each component.

They differ internally in a 2 main respects.

They use 'pin_ptr' instead of 'pin'.

*pin in float input;* +
*pin out float output;* +
becomes +
*pin_ptr in float input;* +
*pin_ptr out float output;* +

They use accessor macros to get/set/increment the pin values.

*output = 1.23;* +
becomes + 
*sf(output, 1.23);*  // sf being s(et)f(loat) +

The header file containing macros is included into all components created with instcomp. +
It is hal_accessor_macros.h 




Last updated 2015-05-31 16:44:22 BST
