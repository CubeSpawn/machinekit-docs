:lang: fr
:toc:

= L'outil de création d'interfaces graphiques GladeVCP

// TODO:
// - manual-example.ui layout - really bad
// - restructure faq/troubleshooting/notes section
// - check wiki vs docs
// - check other gladevcp docs branch against this


:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}
// begin a listing of ini/hal/ngc files like so:
//[source,{ini}]
//[source,{hal}]
//[source,{ngc}]

== Qu'est-ce que GladeVCP?

GladeVCP est un composant d'EMC2 qui donne la possibilité d'ajouter 
de nouvelles interfaces graphiques utilisateur à EMC2 telles qu'Axis ou Touchy. 
À la différence de PyVCP, GladeVCP n'est pas limité à l'affichage et aux
réglages des pins de HAL, toutes les actions peuvent être exécutées en code
Python. En fait, une interface utilisateur EMC2 complète peut être construite 
avec GladeVCP et Python.

GladeVCP utilise l'environnement graphique et WYSIWYG http://glade.gnome.org/[Glade] 
qui simplifie l'édition et la création visuelles de panneaux esthétiquement très
réussis. Il s'appuie sur les liaisons entre http://www.pygtk.org/[PyGTK] et le
riche jeu de widgets http://www.gtk.org/[GTK+], finalement, tous peuvent être 
utilisés dans une application GladeVCP et pas seulement les widgets spécialisés
pour interagir avec HAL et EMC2 présentés ici.

=== PyVCP par rapport à GladeVCP

Tous les deux supportent la création de panneaux avec des 'widgets de HAL', des 
éléments utilisateur visuels tels que boutons, Leds, curseurs etc. dont les 
valeurs sont liées à des pins de HAL qui à leur tour, sont des interfaces pour
le reste d'EMC2.

*PyVCP:*

 - Jeu de widgets: utilise les widgets TkInter.
 - Cycle de création d'interfaces utilisateur: "éditer les fichiers XML/ lancer / évaluer le look".
 - Pas de support pour intégrer une gestion des événements définie par l'utilisateur.
 - Pas d'interaction avec EMC2 au-delà des interactions avec les pins d'E/S de HAL supportées.

*GladeVCP:*

 - Jeu de widgets: Liaison avec le jeu de widgets de http://www.gtk.org/[GTK+].
 - Création d'interface utilisateur: utilise l'interface graphique http://glade.gnome.org/[Glade] 
   qui est un éditeur WYSIWYG.
 - Tout changement sur une pin de HAL peut diriger un appel vers une gestion d'événements 
   définie en Python par l'utilisateur.
 - Tous les signaux GTK (touches/appui sur un bouton, fenêtre, E/S, timer, événements réseau) 
   peuvent être associés avec la gestion d'événements définie en Python par l'utilisateur.
 - Interaction directe avec EMC2: exécution de commandes, telle qu'initialiser une
   commande MDI pour appeler un sous-programme G-code.
 - Plusieurs panneaux GladeVCP indépendants peuvent tourner dans des onglets différents.
 - Séparation entre l'apparence de l'interface et les fonctionnalités: change d'apparence 
   sans passer par aucun code.

== Description du fonctionnement, avec un exemple de panneau

Une fenêtre de panneau GladeVCP peut démarrer avec trois différentes configuration:

 - Toujours visible, intégré dans Axis, du côté droit, exactement comme un panneau PyVCP.
 - Dans un onglet dans Axis ou Touchy; dans Axis un troisième onglet sera créé
   à côté des deux d'origine, ils doivent être choisis explicitement.
 - Comme une fenêtre indépendante, qui peut être iconisée ou agrandie, 
   indépendamment de la fenêtre principale.

Lancer un panneau GladeVCP simple, intégré dans Axis comme PyVCP, taper les 
commandes suivantes:

*+$ cd configs/sim/gladevcp+*

*+$ emc gladevcp_panel.ini+*

image::images/example-panel-small.png[]

Lancer le même panneau, mais dans un onglet d'Axis:

*+$ cd configs/sim/gladevcp+*

*+$ emc gladevcp_tab.ini+*

image::images/example-tabbed-small.png[]

Pour lancer ce même panneau comme une fenêtre d'avant plan sur Axis, démarrer 
Axis en arrière plan puis démarrer gladevcp de la manière suivante:

*+$ cd configs/sim/gladevcp+*

*+$ emc axis.ini &+*

*+$ gladevcp -c gladevcp -u ../gladevcp/hitcounter.py -H ../gladevcp/manual-example.hal ../gladevcp/manual-example.ui+*

image::images/example-float-small.png[]

Pour lancer ce panneau dans 'Touchy':

*+$ cd configs/sim+*

*+$ emc gladevcp_touchy.ini+*

image::images/touchy-tab-33.png[]

Fonctionnellement, ces configurations sont identiques. La seule différence
porte sur l'état et la visibilité de l'écran. Puisqu'il est possible de lancer 
plusieurs composants GladeVCP en parallèle (avec des noms de modules 
de HAL différents), le mélange des configurations est également possible.
Par exemple, un panneau sur le côté droit et un ou plusieurs en onglets pour des
parties d'interface moins souvent utilisées.

=== Description de l'exemple de panneau

Pendant qu'Axis est en marche, explorons 'Afficher configuration de HAL' dans
lequel nous trouvons le composant de HAL 'gladevcp' et dont nous pouvons 
observer la valeur des pins pendant l'interaction avec les widgets du panneau. 
La configuration de HAL peut être trouvée dans 'configs/gladevcp/manual-example.hal'.

Usage des deux cadres en partie basse. Le panneau est configuré pour que, quand 
l'Arrêt d'Urgence est désactivé, le cadre 'Settings' s'active et mette la
machine en marche, ce qui active à son tour le cadre 'Commands' du dessous. 
Les widgets de HAL du cadre 'Settings' sont liés aux Leds et labels du cadre 
'Status' ainsi qu'au numéros de l'outil courant et à celui de l'outil préparé. 
Les utiliser pour bien voir leur effet. L'exécution des commandes 
'T<numéro d'outil>' et 'M6' dans la fenêtre du MDI aura pour effet de changer 
les numéros de l'outil courant et de l'outil préparé dans les champs respectifs.

Les boutons du cadre 'Commands' sont des 'widgets d'action MDI'. Les presser
exécutera une commande MDI dans l'interpréteur. Le troisième bouton 
'Execute Oword subroutine' est un exemple avancé, il prends plusieurs pins de HAL
du cadre 'Settings' et leur passe comme paramètres, le 'sous-programme Oword'. 
Les paramètres actuels reçus par la routine sont affichés par une commande
'(DEBUG, )'. Voir 'configs/gladevcp/nc_files/oword.ngc' pour le corps du
sous-programme.

Pour voir comment le panneau est intégré dans Axis, voir la déclaration de 
'[DISPLAY]GLADEVCP' dans gladevcp_panel.ui, ainsi que les déclarations de
'[DISPLAY]EMBED*' et de '[HAL]POSTGUI_HALFILE' dans 'gladevcp_tab.ini', 
respectivement.

=== Description de l'éditeur de Glade

L'interface utilisateur est créée avec l'éditeur graphique de Glade. Pour 
l'essayer il faut avoir le pré-requis nécessaire, <<gladevcp:Prerequis,que glade soit installé>>. 
Pour éditer l'interface utilisateur, lancer la commande:

*+$ glade configs/gladevcp/manual-example.ui+*

La zone centrale de la fenêtre montre l'apparence de l'interface en création. 
Tous les objets de l'interface et les objets supportés se trouvent dans la partie
haute à droite de la fenêtre, où il est possible de choisir un widget spécifique
(ou en cliquant sur lui au centre de la fenêtre). Les propriétés du widget choisi
sont affichées et peuvent être modifiées, dans le bas à droite de la fenêtre.

Pour voir comment les commandes MDI sont passées depuis les widgets d'action MDI,
explorer la liste des widgets sous 'Actions' en haut à droite de la fenêtre,
et dans le bas à droite de la fenêtre, sous l'onglet 'Général', les propriétés
des 'commandes MDI'.

=== Explorer le callback de Python
Voici comment un callback Python est intégré dans l'exemple:

 - Dans glade, regarder le label du widget +hits+ (un widget GTK+).
 - Dans le widget +button1+, regarder dans l'onglet 'Signaux' et trouver le
   signal 'pressed' associé avec le gestionnaire 'on_button_press'.
 - Dans ../gladevcp/hitcounter.py, regarder la méthode 'on_button_press' 
   et comment elle place la propriété du label dans l'objet 'hits'.

C'était juste pour toucher le concept du doigt. Le mécanisme de callback sera
détaillé plus en détails dans la section <<gladevcp:GladeVCP_Programming,
Programmation de GladeVCP>>.

== Créer et intégrer une interface utilisateur Glade

[[gladevcp:Prerequis]]
=== Prérequis: Installation de Glade

Pour visualiser ou modifier les fichiers d'une interface Glade, Glade doit
être installé. Ce n'est pas nécessaire pour seulement essayer un panneau GladeVCP. 
Si la commande +*glade*+ est manquante, l'installer de la manière suivante:

*+$ sudo apt-get install glade+*

Vérifier ensuite la version installée, qui doit être égale ou supérieure à 3.6.7:

*+$ glade --version+*

*+glade3 3.6.7+*

=== Lancer Glade pour créer une nouvelle interface utilisateur
Cette section souligne juste les étapes initiales spécifiques à EMC2. Pour plus
d'informations et un tutoriel sur Glade, voir http://glade.gnome.org. Certains
trucs & astuces sur Glade, peuvent aussi être trouvés sur http://www.youtube.com[youtube].

Soit modifier une interface existante en lançant +glade <fichier>.ui+ ou,
démarrer une nouvelle en lançant juste la commande +glade+ depuis un terminal.

- Si EMC2 n'a pas été installé depuis un paquetage, l'environnement EMC2 du 
shell doit être configuré avec 
+. <emcdir>/scripts/emc-environment+, autrement Glade ne trouvera pas les widgets
spécifiques à EMC2.
- Quand l'éditeur demande pour enregistrer les préférences, accepter ce qui est
proposé par défaut et presser 'Close'.
- Depuis les 'Niveaux supérieurs' (cadre de gauche), choisir 'Fenêtre' (première icône) 
en haut des Niveaux supérieurs, par défaut cette fenêtre sera nommée 'window1'. 
Ne pas changer ce nom, GladeVCP lui est relié.
- Dans le bas des onglets de gauche, dérouler 'HAL Python' et 'EMC Actions'.
- Ajouter au nouveau cadre, un conteneur comme une boîte HAL_Box ou une 
HAL_Table depuis 'HAL Python'.
- Pointer et placer dans un conteneur d'autres éléments, comme une LED, un bouton, etc.

Le résultat pourrait ressembler à cela:

image::images/glade-manual-small.png[]

Glade a tendance à écrire beaucoup de messages dans la fenêtre du terminal, la
plupart peuvent être ignorés. Sélectionner 'Fichier->Enregistrer sous', donner lui
un nom comme 'myui.ui' et bien vérifier qu'il sera enregistré comme un fichier
'GtkBuilder' (bouton radio en bas à gauche du dialogue d'enregistrement). 
GladeVCP peut aussi traiter correctement l'ancien format 'libglade' mais il n'y 
a aucune raison de l'utiliser. Par convention, l'extension des fichier GtkBuilder 
est '.ui'.

=== Tester un panneau
Vous êtes maintenant prêt à faire un essai (avec EMC2, par exemple Axis en marche)
faites:

*+gladevcp myui.ui+*

GladeVCP crée le composant de HAL portant le nom qui a été donné au fichier, par 
exemple, le très original 'myui.ui' dans notre cas, à moins qu'il n'ait été 
surchargé pat l'option +-c <nom du composant>+. Si Axis est en marche, essayer 
de trouver le composant dans 'Afficher configuration de HAL' et inspecter ses pins.

Vous vous demandez peut être pourquoi les widgets conteneurs comme 'HAL_Hbox' ou
'HAL_Table' apparaissent grisés (inactifs). Les conteneurs HAL ont une pin de HAL
associée qui est désactivée par défaut, c'est ce qui cause ce rendu grisé des
widgets conteneurs inactifs. Un cas d'utilisation courante pourrait être pour
associer les pins de HAL du conteneur +halui.machine.is-on+ ou un des signaux
+halui.mode.+, pour s'assurer que certains widgets n'apparaissent actif que dans
un certain état.

Pour activer un conteneur, exécuter la commande HAL +setp gladevcp.<nom-du-conteneur> 1+.

=== Préparer le fichier de commande HAL
La voie suggérée pour lier les pins de HAL dans un panneau GladeVCP consiste à
les collecter dans un fichier séparé portant l'extension +.hal+. Ce fichier est
passé via l'option +POSTGUI_HALFILE=+, dans la section +[HAL]+ du fichier de
configuration.

ATTENTION: Ne pas ajouter le fichier de commandes HAL de GladeVCP à la section
ini d'Axis +[HAL]HALFILE=+, ça n'aurait pas l'effet souhaité. Voir les sections
suivantes.

=== Intégration dans Axis comme pour PyVCP

Pour placer le panneau GladeVCP dans la partie droite d'Axis, ajouter les lignes
suivantes dans le fichier ini:

[source,{ini}]
----
[DISPLAY]
# ajouter le panneau GladeVCP à l'emplacement de PyVCP:
GLADEVCP= -u ../gladevcp/hitcounter.py ../gladevcp/manual-example.ui

[HAL]
# Les commandes HAL pour les composants GladeVCP dans un onglet, doivent être 
exécutées via POSTGUI_HALFILE
POSTGUI_HALFILE =  ../gladevcp/manual-example.hal

[RS274NGC]
# les sous-programmes Oword spécifiques à gladevcp se placent ici
SUBROUTINE_PATH = ../gladevcp/nc_files/
----

Le nom de composant HAL d'une application GladeVCP lancé avec l'option GLADEVCP 
est toujours: +gladevcp+.
La ligne de commande actuellement lancée par Axis dans la configuration ci-dessous
est la suivante:

 halcmd loadusr -Wn gladevcp gladevcp -c gladevcp -x {XID} <arguments pour GLADEVCP=>

Ce qui veux dire que n'importe quelle option gladevcp, peut être ajoutée ici, tant 
qu'elle n'entre pas en collision avec les options des lignes de commande suivantes.

[NOTE]
L'option +[RS274NGC]SUBROUTINE_PATH=+ est fixée seulement pour que l'exemple de
panneau puisse trouver le sous-programme Oword pour le widget de commande MDI. Il
n'est peut être pas nécessaire dans votre configuration.

=== Intégration dans un nouvel onglet d'Axis à la suite des autres

Pour cela, éditer le fichier .ini et ajouter dans les sections DISPLAY et HAL,
les lignes suivantes:
[source,{ini}]
----
[DISPLAY]
# ajoute le panneau GladeVCP dans un nouvel onglet:
EMBED_TAB_NAME=GladeVCP demo
EMBED_TAB_COMMAND=halcmd loadusr -Wn gladevcp gladevcp -c gladevcp -x {XID} -u ../gladevcp/hitcounter.py ../gladevcp/manual-example.ui

[HAL]
# commandes HAL pour le composant GladeVCP dans un onglet doit être exécuté via POSTGUI_HALFILE
POSTGUI_HALFILE =  ../gladevcp/manual-example.hal

[RS274NGC]
# les sous-programmes Oword spécifiques à gladevcp se placent ici
SUBROUTINE_PATH = ../gladevcp/nc_files/
----

Noter le 'halcmd loadusr' pour charger la commande d'onglet, elle assure que
'POSTGUI_HALFILE' ne sera lancé que seulement après que le composant de HAL ne soit 
prêt. Dans de rares cas, une commande pourrait être lancée ici, pour utiliser 
un onglet sans être associée à un composant de HAL. Une telle commande pourrait 
être lancée sans 'halcmd loadusr', ce qui indiquerait à Axis qu'il ne doit plus 
attendre un composant de HAL, puisqu'il n'existe pas.

Noter que quand le nom du composant est changé dans l'exemple suivant, les noms 
utilisés dans +-Wn <composant>+ et +-c <composant>+ doivent être identiques.

Essayer en lançant Axis, il doit avoir un nouvel onglet appelé 'GladeVCP demo' 
à droite de l'onglet de la visu. Sélectionner cet onglet, le panneau de l'exemple
devrait être visible, bien intégré à Axis.

[NOTE]
Bien vérifier que le fichier de l'interface est la dernière option passée à 
GladeVCP dans les deux déclarations +GLADEVCP=+ et +EMBED_TAB_COMMAND=+.

=== Intégration dans Touchy
Pour ajouter un onglet GladeVCP à 'Touchy', éditer le fichier .ini comme cela:
[source,{ini}]
-------------------------------------------------------
[DISPLAY]
# ajoute un panneau GladeVCP dans un onglet
EMBED_TAB_NAME=GladeVCP demo
EMBED_TAB_COMMAND=gladevcp -c gladevcp -x {XID} -u ../gladevcp/hitcounter.py -H ../gladevcp/gladevcp-touchy.hal  ../gladevcp/manual-example.ui

[RS274NGC]
# les sous-programmes Oword spécifiques à gladevcp se placent ici
SUBROUTINE_PATH = ../gladevcp/nc_files/
-------------------------------------------------------

Noter les différences suivantes avec la configuration de l'onglet d'Axis:

 - Le fichier de commandes HAL est légèrement modifié puisque 'Touchy' n'utilise
   pas le composant 'halui', ses signaux ne sont donc pas disponibles et certains
   raccourcis ont été pris.

 - Il n'y a pas d'option 'POSTGUI_HALFILE=', mais il est correct, de passer le 
   fichier de commandes HAL, par la ligne 'EMBED_TAB_COMMAND='.

 - L'appel 'halcmd loaduser -Wn ...' n'est pas nécessaire.

== Options de GladeVCP en ligne de commande

Voir également, 'man gladevcp'. Ce sont les options pour cette ligne de 
commande:

Usage: gladevcp [options] myfile.ui

Options:

-h, --help::
    Affiche ce message d'aide et sort.

-c NAME::
    Fixe le nom du composant à NAME. Par défaut, le nom de base des fichiers UI

-d::
    Active la sortie débogage

-g GEOMETRY::
     Fixe la géométrie à WIDTHxHEIGHT+XOFFSET+YOFFSET. Les valueurs sont en pixels,
    XOFFSET/YOFFSET est référencé à partir du coin haut, à gauche de l'écran.
    Utilise -g WIDTHxHEIGHT pour fixer une taille ou -g +XOFFSET+YOFFSET pour 
    fixer une position 

-H FILE::
    exécute les déclarations de HAL depuis FILE, avec halcmd après que le composant 
    soit chargé et prêt

-m MAXIMUM::
    force la fenêtre du panneau à se maximiser. Toutefois avec l'option -g geometry 
    le panneau est déplaçable d'un moniteur à un autre en le forçant à utiliser 
    toute l'écran

-t THEME::
    fixe le thème gtk. Par défaut, le thème système. Différents panneaux peuvent
    avoir différents thèmes.
    Un exemple de thème peut être trouvé sur le http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?GTK_Themes[Wiki d'EMC2].

-x XID::
    Redonne un parent GladeVCP dans une fenêtre existante XID au lieu d'en 
    créer une nouvelle au niveau supérieur

-u FILE::
    Utilise les FILE comme modules définis par l'utilisateur avec le gestionnaire

-U USEROPT::
    passe les modules python USEROPT

== Références des Widgets HAL

GladeVcp inclus une collection de widgets Gtk qui ont des pins de HAL attachées,
appelés widgets HAL, il sont destinés à contrôler, à afficher et à avoir d'autres
interactions avec la couche HAL EMC. Il sont destinés à être utilisés avec les 
interfaces créées par l'éditeur de Glade. Avec une installation correcte, les 
widgets HAL devraient être visible, dans l'éditeur Glade, dans le groupe des 
Widgets 'HAL Python'. Beaucoup de champs spécifiques à HAL dans l'onglet 'Général'
affichent une bulle d'information au survol de la souris.

Il y a deux variantes de signaux de HAL, bits et nombres. Les signaux
bits sont les on/off. Les nombres peuvent être des "float", des "s32" ou
des "u32". Pour plus d'informations sur les types de données de HAL, 
voir le manuel de HAL. Les widgets GladeVcp peuvent soit, 
afficher la valeur d'un signal avec un widget d'indication, soit, modifier la 
valeur d'un signal avec un widget de contrôle. Ainsi, il existe quatre classes 
de widgets gladvcp qui peuvent être connectés à un signal de HAL. Une autre 
classe de widgets d'aide permettent d'organiser et d'étiqueter les panneaux.

 - Widgets d'indications "bit" signals: <<gladevcp:HAL_LED,LED HAL>>
 - Widgets de contrôle "bit" signals: <<gladevcp:HAL_Button,HAL Bouton>>,
   <<gladevcp:HAL_Button,HAL Bouton Radio>>,
   <<gladevcp:HAL_Button,HAL Case à cocher>>
 - Widgets d'indications "nombre" signals: <<gladevcp:HAL_Label>>,
   <<gladevcp:HAL_ProgressBar,HAL Barre de progression>>,
   <<gladevcp:HAL_HBar,HAL HBar>>, <<gladevcp:HAL_HBar,HAL VBar>>,
   <<gladevcp:HAL_Meter,HAL Indicateur à aiguille>>
 - Widgets de contrôle "nombre" signals: <<gladevcp:HAL_SpinButton,Roue codeuse>>,
   <<gladevcp:HAL_HScale,HAL HScale>>,
   <<gladevcp:HAL_HScale,HAL VScale>>
 - widgets d'aide: <<gladevcp:HAL_HBox,HAL Table>>, <<gladevcp:HAL_HBox,HAL HBox>>
 - Tracé du parcours d'outil: <<gladevcp:HAL_Gremlin,HAL Gremlin>>

Les widgets HAL héritent des méthodes, propriétés et signaux des widgets Gtk 
sous-jacents, il est donc utile de consulter le site du http://www.gtk.org/[GTK+] 
ainsi que celui de la documentation des http://www.pygtk.org/[liaisons PyGTK].

=== Nommage des Widgets HAL et de leurs pins

La plupart des widgets HAL on une simple pin de HAL associée et portant le même 
nom que le widget (glade: Général->Nom).

Les exceptions à cette règle sont actuellement:

- 'HAL_Spinbutton' et 'HAL_ComboBox', qui ont deux pins: une pin 
   +<widgetname>-f+ (float) et une pin +<widgetname>-s+ (s32)
- 'HAL_ProgressBar', qui a une pin d'entrée +<widgetname>-value+, et une pin 
d'entrée +<widgetname>-scale+.

=== Donner des valeurs aux Widgets HAL et à leurs pins

En règle générale, si une valeur doit être attribuée à la sortie d'un widget HAL
depuis un code Python, le faire en appelant le 'setter' Gtk sous-jacent (par
exemple +set_active()+, +set_value()+), ne pas essayer de donner directement la 
valeur à la pin associée par un +halcomp[nompin] = value+, parce-que le widget
ne verra jamais le changement!.

Il pourrait être tentant de 'fixer une pin d'entrée de widget HAL' par programme.
Noter que cela va à l'encontre du but premier d'une pin d'entrée. Elle devrait 
être attachée à un autre composant de HAL et réagir au signal qu'il génère. Bien
qu'aucune protection, empêchant d'écrire sur les pins d'entrée HAL Python, ne soit 
présente actuellement, cela n'aurait aucun sens. Il faut utiliser +setp nompin valeur+
dans un fichier Hal associé, pour les essais.

Il est par contre, parfaitement autorisé de mettre une valeur sur une pin de 
sortie de Hal avec +halcomp[nompin] = valeur+ à condition que cette pin ne soit
pas déjà associée avec un autre widget, ce qui aurait pu être créé par la méthode 
+hal_glib.GPin(halcomp.newpin(<nom>,<type>,<direction>)+. Voir <<gladevcp:GladeVCP_Programming,Programmation de GladeVCP>> pour d'autres exemples.

[[gladevcp::hal-pin-changed_signal]]
=== Le signal 'hal-pin-changed'

La programmation événementielle signifie que l'interface graphique indique au 
code quand "quelque chose se produit", grâce à un callback, comme quand un 
bouton est pressé, la sortie du widget HAL (ceux qui affichent la valeur des pins 
de HAL) comme une LED, une barre, une VBar, un indicateur à aiguille etc, 
supportent le signal 'hal-pin-changed' qui peut provoquer un callback dans le 
code Python quand une pin de HAL change de valeur. Cela veut dire qu'il n'est 
plus nécessaire d'interroger en permanence les pins de HAL dans le code pour 
connaitre les changements, les widgets font ça en arrière plan et le font savoir.

Voici un exemple montrant comment régler un signal +hal-pin-changed+ pour
une Hal Led, dans l'éditeur de Glade:

image::images/hal-pin-change-66.png[]
L'exemple dans +configs/gladevcp/examples/complex+ montre comment c'est géré 
en Python.

[[gladevcp:HAL_Button]]
=== Les boutons

Ce groupe de widgets est dérivé de divers boutons Gtk, ce sont les widgets
HAL_Button, HAL_ToggleButton, HAL_RadioButton et CheckButton. Tous ont une seule
pin de sortie BIT portant un nom identique au widget. Les boutons n'ont pas d'autres
propriétés additionnelles, contrairement à leurs classes de base Gtk.

 - HAL_Button: Action instantanée, ne retient pas l'état. 
   Signal important: +pressed+.
 - HAL_ToggleButton, HAL_CheckButton: Retiennent l'état on/off. 
   Signal important: +toggled+.
 - HAL_RadioButton: Un parmi un groupe. Signal important: +toggled+ (par bouton).
 - Importante méthodes commune: +set_active()+, +get_active()+
 - Importante propriétés: +label+, +image+


// .Boutons
Case à cocher:
image:images/checkbutton.png[]
Boutons radio:
image:images/radiobutton.png[]
Bouton à bascule:
image:images/button.png[]


[TIP]
====
Définir les groupes de boutons radio dans Glade:

- Décider du bouton actif par défaut

- Dans les boutons radio, 'Général->Groupe' sélectionner le nom du bouton actif 
  par défaut dans le dialogue 'Choisir un Bouton radio pour ce projet'.

Voir +configs/gladevcp/by-widget/radiobutton+ pour une application GladeVCP avec 
un fichier d'interface utilisateur, pour travailler sur les boutons radio.
====

[[gladevcp:HAL_VScale]]

[[gladevcp:HAL_HScale]]
=== Les échelles (scales)

HAL_HScale et HAL_VScale sont respectivement dérivées de GtkHScale et GtkVScale. 
Elles ont une pin de sortie FLOAT portant le même nom que le widget. Les échelles
n'ont pas de propriété additionnelle.

Pour créer une échelle fonctionnelle dans Glade, ajouter un 'Ajustement'
(Général->Ajustement->Nouveau ou existant) et éditer l'objet ajustement. Il défini
les valeurs défaut/min/max/incrément. Fixer également les 'Page size' et 
'Page incrément' de l'ajustement à zéro pour éviter les warnings.

Exemple d'échelle (HAL_hscale):
image:images/hscale.png[]
.

[[gladevcp:HAL_SpinButton]]
=== La roue codeuse (SpinButton)

La roue codeuse de HAL est dérivée de GtkSpinButton et a deux pins:

<widgetname>-f::
	 out FLOAT pin
<widgetname>-s::
	 out S32 pin

Pour être fonctionnelle, Spinbuttons doit avoir une valeur d'adjustment comme scales,
vue précédemment.

Exemple de roue codeus:
image:images/spinbutton.png[]
.

[[gladevcp:HAL_Label]]
=== Les labels

HAL_Label is a simple widget based on GtkLabel which represents a HAL
pin value in a user-defined format.

label_pin_type::
	The pin's HAL type  (0:S32, 1:float, 2:U32), see also the tooltip
	on 'General->HAL pin type '(note this is different from PyVCP which has
	three label widgets, one for each type).

text_template::
	Determines the text displayed - a Python
	format string to convert the pin value to text. Defaults to +%s+ (values
	are converted by the str() function) but may contain any legit as an
	argument to Pythons format() method. +
	Example: +Distance: %.03f+ will display the text and the pin value with
	3 fractional digits padded with zeros for a FLOAT pin.


[[gladevcp:HAL_Table]]

[[gladevcp:HAL_HBox]]
=== Containers: HAL_HBox and HAL_Table

Compared to their Gtk counterparts they have one input BIT pin which
controls if their child widgets are sensitive or not. If the pin is low
then child widgets are inactive which is the default.

[TIP]
If you find some part of your GladeVCP application is 'grayed
out' (insensitive), see whether a container's pin is unset.

[[gladevcp:HAL_LED]]
=== LED

The hal_led simulates a real indicator LED. It has a single input BIT
pin which controls it's state: ON or OFF. LEDs have several properties
which control their look and feel:

on_color::
   a String defining ON color of LED. May be any valid
   gtk.gdk.Color name. Not working on Ubuntu 8.04.
off_color::
   String defining OFF color of LED. May be any valid
   gtk.gdk.Color name or special value `dark`. `dark` means that OFF color
   will be set to 0.4 value of ON color. Not working on Ubuntu 8.04.
pick_color_on, pick_color_off::
   Colors for ON and OFF states may be
   represented as `#RRRRGGGGBBBB` strings. These are optional properties
   which have precedence over `on_color` and `off_color`.
led_size::
   LED radius (for square - half of LED's side)
led_shape::
   LED Shape. Valid values are 0 for round, 1 for oval and 2
   for square shapes.
led_blink_rate::
   if set and LED is ON then it's blinking. Blink
   period is equal to "led_blink_rate" specified in milliseconds.

As an input widget, LED also supports the +hal-pin-changed signal+. If
you want to get a notification in your code when the LED's HAL pin was
changed, then connect this signal to a handler, for example
+on_led_pin_changed+ and provide the handler as follows:

[source,python]
----------------------------------
def on_led_pin_changed(self,hal_led,data=None):
    print "on_led_pin_changed() - HAL pin value:",hal_led.hal_pin.get()
----------------------------------

This will be called at any edge of the signal and also during program
start up to report the current value.

Example LEDs:
image:images/leds.png[]
.

[[gladevcp:HAL_ProgressBar]]
=== ProgressBar

[NOTE]
This widget might go away. Use the HAL_HBar and HAL_VBar widgets
instead.

The HAL_ProgressBar is derived from gtk.ProgressBar and has two float
HAL input pins:

<widgetname>::
	the current value to be displayed
<widgetname>-scale::
	the maximum absolute value of input

It has the following properties:

scale::
	value scale. set maximum absolute value of input. Same as
	setting the <widgetname>.scale pin. A float, range from
	-2^24^ à +2^24^.
green_limit::
      green zone limit lower limit
yellow_limit::
      yellow zone limit lower limit
red_limit::
      red zone limit lower limit
text_template::
      Text template to display the current value of the
      +<widgetname>+ pin. Python formatting may be used for dict
      +{"value":value}+

Example HAL_ProgressBar:
image:images/progressbar2.png[]
.

[[gladevcp:HAL_ComboBox]]
=== ComboBox

HAL_ComboBox is derived from gtk.ComboBox. It enables choice of a
value from a dropdown list.

It exports two HAL pins:

 <widgetname>-f::
		  the current value, type FLOAT
 <widgetname>-s::
		  the current value, type S32

It has the following property which can be set in Glade:

column::
	 the column index, type S32, defaults to -1, range from -1..100 .

In default mode this widgets sets the pins to the index of the chosen
list entry. So if your widget has three labels, it may only assume
values 0,1 and 2.

In column mode (column > -1), the value reported is chosen from the
ListStore array as defined in Glade. So typically your widget
definition would have two columns in the ListStore , one with text
displayed in the dropdown, and an int or float value to use for that
choice.

There's an example in
+configs/gladevcp/by-widget/combobox/combobox.{py,ui}+ which uses column
mode to pick a float value from the ListStore.

If you're confused like me about how to edit ComboBox ListStores and
CellRenderer, see http://www.youtube.com/watch?v=Z5_F-rW2cL8.

[[gladevcp:HAL_VBar]]

[[gladevcp:HAL_HBar]]
=== Bars

HAL Bar and VBar widgets for horizontal and vertical bars representing
float values. They have one input FLOAT hal pin. Both bars have the
following properties:

invert::
   Swap min and max direction. An inverted HBar grows from right
   to left, an inverted VBar from top to bottom.
min, max::
   Minimum and maximum value of desired range. It is not an
   error condition if the current value is outside this range.
zero::
   Zero point of range. If it's inside of min/max range then the
   bar will grow from that value and not from the left (or right) side of
   the widget. Useful to represent values that may be both positive or
   negative.
force_width, force_height::
   Forced width or height of widget. If not
   set then size will be deduced from packing or from fixed widget size
   and bar will fill whole area.
text_template::
   Like in Label sets text format for min/max/current
   values. Can be used to turn off value display.
bg_color::
   Background (inactive) color of bar.
z0_color, z1_color, z2_color::
   Colors of different value zones.
   Defaults are `green`, `yellow` and `red`. For description of zones see
   `z*_border` properties.
z0_border, z1_border::
   Define up bounds of color zones. By default
   only one zone is enabled. If you want more then one zone set
   `z0_border` and `z1_border` to desired values so zone 0 will fill from
   0 to first border, zone 1 will fill from first to second border and
   zone 2 -- from last border to 1. Borders are set as fractions, values
   from 0 to 1.

Horizontal bar:
image:images/hal_hbar.png[]
Vertical bar:
image:images/vscale.png[]
.

[[gladevcp:HAL_Meter]]
=== Meter

HAL Meter is a widget similar to PyVCP meter - it represents a float value and has 
one input FLOAT hal pin. HAL Meter has the following properties:

min, max::
   Minimum and maximum value of desired range. It is not an
   error condition if the current value is outside this range.
force_size::
   Forced diameter of widget. If not set then size will be
   deduced from packing or from fixed widget size and meter will fill all
   available space with respect to aspect ratio.
text_template::
   Like in Label sets text format for current value. Can
   be used to turn off value display.
label::
   Large label above center of meter.
sublabel::
   Small label below center of meter.
bg_color::
   Background color of meter.
z0_color, z1_color, z2_color::
   Colors of different value
   zones. Defaults are `green`, `yellow` and `red`. For description of
   zones see `z*_border` properties.
z0_border, z1_border::
   Define up bounds of color zones. By default only
   one zone is enabled. If you want more then one zone set `z0_border` and
   `z1_border` to desired values so zone 0 will fill from min to first
   border, zone 1 will fill from first to second border and zone 2 -- from
   last border to max. Borders are set as values in range min-max.

Example HAL Meters:

image::images/hal_meter.png[]
.

[[gladevcp:HAL_Gremlin]]
=== Gremlin tool path preview for .ngc files

Gremlin is a plot preview widget similar to the Axis preview window.
It assumes a running EMC environment like Axis or Touchy. To connect to
it, inspects the INI_FILE_NAME environment variable. Gremlin displays
the current .ngc file - it does monitor for changes and reloads the ngc
file if the file name in Axis/Touchy changes. If you run it in a
GladeVCP application when EMC is not running, you might get a traceback
because the Gremlin widget can't find EMC status, like the current file
name.

Gremlin does not export any HAL pins. It has the following properties:

view ::
   may be any of `x`, `y`, `z`, `p` (perspective) . Defaults to
   `z` view.
enable_dro ::
   boolean; whether to draw a DRO on the plot or not.
   Defaults to `True`.

Example:

image::images/gremlin.png[]


=== Animated function diagrams: HAL widgets in a bitmap

For some applications it might be desirable to have background image -
like a functional diagram - and position widgets at appropriate places
in that diagram. A good combination is setting a bitmap background
image, like from a .png file, making the gladevcp window fixed-size,
and use the glade Fixed widget to position widgets on this image.

The code for the below example can be found in +configs/gladevcp/animated-backdrop+:

image::images/small-screenshot.png[]

== Action Widgets reference

GladeVcp includes a collection of "canned actions" called EMC Action
Widgets for the Glade user interface editor. Other than HAL widgets,
which interact with HAL pins, EMC Actions interact with EMC and the
G-code interpreter.

EMC Action Widgets are derived from the Gtk.Action widget. The Action
widget in a nutshell:

 - it is an object available in Glade
 - it has no visual appearance by itself
 -  it's purpose: associate a visible, sensitive UI component like menu,
   toolbutton, button with a command. See these widget's 'General->Related
   Action' property.
 -  the "canned action" will be executed when the associated UI component
   is triggered (button press, menu click..)
 -  it provides an easy way to execute commands without resorting to
   Python programming.

The appearance of EMC Actions in Glade is roughly as follows:

image::images/emc-actions.png[]

Tooltip hovers provide a description.


=== EMC Action widgets

EMC Action widgets are one-shot type widgets. They implement a single action and
are for use in simple buttons, menu entries or radio/check groups.

=== EMC ToggleAction widgets

These are bi-modal widgets. They implement two actions or use a second
(usually pressed) state to indicate that currently an action is
running. Toggle actions are aimed for use in ToggleButtons,
ToggleToolButtons or toggling menu items. A simplex example is the
ESTOP toggle button.

Currently the following widgets are available:

 - The ESTOP toggle sends ESTOP or ESTOP_RESET commands to EMC depending
   on it's state.
 - The ON/OFF toggle sends STATE_ON and STATE_OFF commands.
 - Pause/Resume sends AUTO_PAUSE or AUTO_RESUME commands.

The following toggle actions have only one associated command and use
the 'pressed' state to indicate that the requested operation is
running:

 - The Run toggle sends an AUTO_RUN command and waits in the pressed
   state until the interpreter is idle again.
 - The Stop toggle is inactive until the interpreter enters the active
   state (is running G-code) and then allows user to send AUTO_ABORT
   command.
 - The MDI toggle sends given MDI command and waits for its completion in
   'pressed' inactive state.

=== The Action_MDI Toggle and Action_MDI widgets

These widgets provide a means to execute arbitrary MDI commands. The
Action_MDI widget does not wait for command completion as the
Action_MDI Toggle does, which remains disabled until command complete.

=== A simple example: Execute MDI command on button press

+configs/gladevcp/mdi-command-example/whoareyou.ui+ is a Glade UI file which conveys the basics:

Open it in Glade and study how it's done. Start Axis, and then start
this from a terminal window with `gladevcp whoareyou.ui`. See the
+hal_action_mdi1+ Action and it's +MDI command+ property - this just
executes +(MSG, "Hi, I'm an EMC_Action_MDI")+ so there should be a
message popup in Axis like so:

image::images/whoareyou.png[]

You'll notice that the button associated with the Action_MDI action is
grayed out if the machine is off, in E-Stop or the interpreter is running.
It will automatically become active when the machine is turned on and
out of E-Stop, and the program is idle.

=== Parameter passing with Action_MDI and ToggleAction_MDI widgets

Optionally, 'MDI command' strings may have parameters substituted
before they are passed to the interpreter. Parameters currently may be
names of HAL pins in the GladeVCP component. This is how it works:

 - assume you have a 'HAL SpinBox' named +speed+, and you want to pass it's
   current value as a parameter in an MDI command.
 - The HAL SpinBox will have a float-type HAL pin named speed-f (see
   HalWidgets description).
 - To substitute this value in the MDI command, insert the HAL pin name
   enclosed like so: `${pin-name}`
 - for the above HAL SpinBox, we could use `(MSG, "The speed is:
   ${speed-f}")` just to show what's happening.

The example UI file is +configs/gladevcp/mdi-command-example/speed.ui+. Here's what you get when running it:


image::images/speed.png[]

=== An advanced example: Feeding parameters to an O-word subroutine

It's perfectly OK to call an O-word subroutine in an MDI command, and
pass HAL pin values as actual parameters. An example UI file
is in +configs/gladevcp/mdi-command-example/owordsub.ui+.

Place +configs/gladevcp/nc_files/oword.ngc+ so Axis can find it, and run `gladevcp owordsub.ui` from
a terminal window. This looks like so:

image::images/oword.png[]

=== Preparing for an MDI Action, and cleaning up afterwards

The EMC G-Code interpreter has a single global set of variables, like
feed, spindle speed, relative/absolute mode and others. If you use G
code commands or O-word subs, some of these variables might get changed
by the command or subroutine - for example, a probing subroutine will
very likely set the feed value quite low. With no further precautions,
your previous feed setting will be overwritten by the probing
subroutine's value.

To deal with this surprising and undesirable side effect of a given
O-word subroutine or G-code statement executed with an EMC
ToggleAction_MDI, you might associate pre-MDI and post-MDI handlers
with a given EMC ToggleAction_MDI. These handlers are optional and
provide a way to save any state before executing the MDI Action, and to
restore it to previous values afterwards. The signal names are +mdi-command-start+
and +mdi-command-stop+; the handler names can be set in Glade like any
other handler.

Here's an example how a feed value might be saved and restored by such
handlers (note that EMC command and status channels are available as
+self.emc+ and +self.stat+ through the EMC_ActionBase class:

[source,python]
----------------------------------
    def on_mdi_command_start(self, action, userdata=None):
        action.stat.poll()
        self.start_feed = action.stat.settings[1]
    
    def on_mdi_command_stop(self, action, userdata=None):
        action.emc.mdi('F%.1f' % (self.start_feed))
        while action.emc.wait_complete() == -1:
            pass
----------------------------------

Only the Action_MDI Toggle widget supports these signals.

[NOTE]
In a later release of EMC2, the new M-codes M70-M72 are available which
make it saving state before a subroutine call, and restoring state on return much easier.

=== Using the EMC Stat object to deal with status changes

Many actions depend on EMC status - is it in manual, MDI or auto mode?
is a program running, paused or idle? You cannot start an MDI command
while a G-code program is running, so this needs to be taken care of.
Many EMC actions take care of this themselves, and related buttons and
menu entries are deactivated when the operation is currently
impossible.

When using Python event handlers - which are at a lower level than
Actions - one needs to take care of dealing with status dependencies
oneself. For this purpose, there's the EMC Stat widget: to associate
EMC status changes with event handlers.

EMC Stat has no visible component - you just add it to your UI with
Glade. Once added, you can associate handlers with its following
signals:

* state-related:     emitted when E-Stop condition occurs, is reset, machine is turned on, or is turned off
  - +state-estop+
  - +state-estop-reset+
  - +state-on+,
  - +state-off+
* mode-related:    emitted when EMC enters that particular mode
  - +mode-manual+
  - +mode-mdi+
  - +mode-auto+
* interpreter-related:  emitted when the G-code interpreter changes into that mode
  - +interp-run+
  - +interp-idle+
  - +interp-paused+
  - +interp-reading+
  - +interp-waiting+


[[gladevcp:GladeVCP_Programming]]
== Programmation de GladeVCP

=== User Defined Actions

Most widget sets, and their associated user interface editors, support
the concept of callbacks - functions in user-written code which are
executed when 'something happens' in the UI - events like mouse clicks,
characters typed, mouse movement, timer events, window hiding and
exposure and so forth.

HAL output widgets typically map input-type events like a button press
to a value change of the associated HAL pin by means of such a -
predefined - callback. Within PyVCP, this is really the only type of event
handling supported - doing something more complex, like executing MDI
commands to call a G-code subroutine, is not supported.

Within GladeVCP, HAL pin changes are just one type of the general
class of events (called signals) in GTK+. Most widgets may originate such
signals, and the Glade editor supports associating such a signal with a
Python method or function name.

If you decide to use user-defined actions, your job is to write a
Python module whose class methods - or in the simple case, just
functions - can be referred to in Glade as event handlers. GladeVCP
provides a way to import your module(s) at startup and will
automatically link your event handlers with the widget signals as set
in the Glade UI description.

=== An example: adding custom user callbacks in Python

This is just a minimal example to convey the idea - details are laid
out in the rest of this section.

GladeVCP can not only manipulate or display HAL pins, you can also
write regular event handlers in Python. This could be used, among
others, to execute MDI commands. Here's how you do it:

Write a Python module like so and save as e.g. handlers.py:

[source,python]
----
nhits = 0
def on_button_press(gtkobj,data=None):
    global nhits nhits += 1 gtkobj.set_label("hits: %d" % nhits)
----

In Glade, define a button or HAL button, select the 'Signals' tab, and
in the GtkButton properties select the 'pressed' line. Enter
'on_button_press' there, and save the Glade file.

Then add the option '-u handlers.py' to the gladevcp command line. If
your event handlers are spread over several files, just add multiple
'-u <pyfilename>' options.

Now, pressing the button should change its label since it's set in the
callback function.

What the +-u+ flag does: all Python functions in this file are
collected and setup as potential callback handlers for your Gtk widgets
- they can be referenced from Glade 'Signals' tabs. The callback
handlers are called with the particular object instance as parameter,
like the GtkButton instance above, so you can apply any GtkButton
method from there.

Or do some more useful stuff, like calling an MDI command!

=== HAL value change events

HAL input widgets, like a LED, automatically associate their HAL pin state
(on/off) with the optical appearance of the widget (LED lit/dark).

Beyond this builtin functionality, one may associate a change
callback with any HAL pin, including those of predefined HAL
widgets. This fits nicely with the event-driven structure of a typical
widget application: every activity, be it mouse click, key, timer
expired, or the change of a HAL pin's value, generates a callback and
is handled by the same orthogonal mechanism.

For user-defined HAL pins not associated with a particular HAL widget,
the signal name is 'value-changed'. See the
<<gladevcp:Adding_HAL_pins,Adding HAL pins>> section below for
details.

HAL widgets come with a pre-defined signal called 'hal-pin-changed'. See the
<<gladevcp::hal-pin-changed_signal,Hal Widgets section>> for details. 


=== Programming model

The overall approach is as follows:

 - design your UI with Glade, and set signal handlers where you want
   actions associated with a widget
 - write a Python module which contains callable objects (see 'handler
   models' below)
 - pass your module's path name to gladevcp with the '-u <module>' option
 - gladevcp imports the module, inspects it for signal handlers and
   connects them to the widget tree
 - the main event loop is run.

==== The simple handler model

For simple tasks it's sufficient to define functions named after the
Glade signal handlers. These will be called when the corresponding
event happens in the widget tree. Here's a trivial example - it assumes
that the 'pressed' signal of a Gtk Button or HAL Button is linked to a
callback called 'on_button_press':

[source,python]
----------------------------------
nhits = 0
def on_button_press(gtkobj,data=None):
    global nhits
    nhits += 1
    gtkobj.set_label("hits: %d" % nhits)
----------------------------------

Add this function to a Python file and run as follows:

    gladevcp -u <myhandler>.py mygui.ui

Note communication between handlers has to go through global
variables, which does not scale well and is positively un-pythonic.
This is why we came up with the class-based handler model.

==== The class-based handler model

The idea here is: handlers are linked to class methods. The underlying
class(es) are instantiated and inspected during GladeVCP startup and
linked to the widget tree as signal handlers. So the task now is to
write:

 -  one or more several class definition(s) with one or several methods,
   in one module or split over several modules,
 -  a function 'get_handlers' in each module which will return a list of
   class instances to GladeVCP - their method names will be linked to
   signal handlers

Here is a minimum user-defined handler example module:

[source,python]
----------------------------------
class MyCallbacks :
    def on_this_signal(self,obj,data=None):
        print "this_signal happened, obj=",obj
    def get_handlers(halcomp,builder,useropts):
        return [MyCallbacks ()]
----------------------------------

Now, 'on_this_signal' will be available as signal handler to your
widget tree.

==== The get_handlers protocol

If during module inspection GladeVCP finds a function `get_handlers`,
it calls it as follows:

    get_handlers(halcomp,builder,useropts)

the arguments are:

 - halcomp - refers to the HAL component under construction
 - builder - widget tree - result of reading the UI definition (either
   referring to a GtkBuilder or libglade-type object)
 - useropts - a list of strings collected from the gladevcp 
   command line `-U <useropts>` option

GladeVCP then inspects the list of class instances and retrieves their
method names. Qualifying method names are connected to the widget tree
as signal handlers. Only method names which do not begin with an '_'
(underscore) are considered.

Note that regardless whether you're using the libglade or the new
GtkBuilder format for your Glade UI, widgets can always be referred to
as `builder.get_object(<widgetname>)`. Also, the complete list of
widgets is available as `builder.get_objects()` regardless of UI
format.

=== Initialization sequence

It is important to know in which state of affairs your `get_handlers()`
function is called so you know what is safe to do there and what not.
First, modules are imported and initialized in command line order.
After successful import, `get_handlers()` is called in the following
state:

 -  the widget tree is created, but not yet realized (no toplevel
   `window.show()` has been executed yet)
 -  the halcomp HAL component is set up and all HAL widget's pins have
   already been added to it
 -  it is safe to add more HAL pins because `halcomp.ready()` has not yet
   been called at this point, so you may add your own pins, for instance
   in the class `__init__()` method.

Once all modules have been imported and method names extracted, the
following steps happen:

 -  all qualifying method names will be connected to the widget tree with
   `connect_signals()/signal_autoconnect()` (depending on the type of UI
   imported - GtkBuilder vs the old libglade format).
 - the HAL component is finalized with halcomp.ready()
 -  if a window ID was passed as argument, the widget tree is re-parented
   to run in this window, and Glade's toplevel window1 is abandoned (see
   FAQ)
 -  if a HAL command file was passed with `-H halfile`, it is executed
   with halcmd
 - the Gtk main loop is run.

So when your handler class is initialized, all widgets are existent
but not yet realized (displayed on screen). And the HAL component isn't
ready as well, so its unsafe to access pins values in your `__init__()`
method.

If you want to have a callback to execute at program start after it is
safe to access HAL pins, then a connect a handler to the realize signal
of the top level window1 (which might be its only real purpose). At
this point GladeVCP is done with all setup tasks, the halfile has been
run, and GladeVCP is about to enter the Gtk main loop.

=== Multiple callbacks with the same name

Within a class, method names must be unique. However, it is OK to have
multiple class instances passed to GladeVCP by get_handlers() with
identically named methods. When the corresponding signal occurs, these
methods will be called in definition order - module by module, and
within a module, in the order class instances are returned by
`get_handlers()`.

=== The GladeVCP `-U <useropts>` flag

Instead of extending GladeVCP for any conceivable option which could
potentially be useful for a handler class, you may use the -U
<useroption> flag (repeatedly if you wish). This flag collects a list
of <useroption> strings. This list is passed to the get_handlers()
function (useropts argument). Your code is free to interpret these
strings as you see fit. An possible usage would be to pass them to the
Python exec function in your `get_handlers()` as follows:

[source,python]
----------------------------------
debug = 0
...
def get_handlers(halcomp,builder,useropts):
    ...
    global debug # assuming there's a global var
    for cmd in useropts:
        exec cmd in globals()
----------------------------------

This way you can pass arbitrary Python statements to your module
through the gladevcp -U option, for example:

    gladevcp -U debug=42 -U "print 'debug=%d' % debug" ...

This should set debug to 2 and confirm that your module actually did it.

=== Persistent variables in GladeVCP

A annoying aspect of GladeVCP in its earlier form and pyvcp is the
fact that you may change values and HAL pins through text entry,
sliders, spin boxes, toggle buttons etc, but their settings are not
saved and restored at the next run of EMC - they start at the default
value as set in the panel or widget definition.

GladeVCP has an easy-to-use mechanism to save and restore the state of
HAL widgets, and program variables (in fact any instance attribute of
type int, float, bool or string).

This mechanism uses the popular '.ini' file format to save and reload
persistent attributes.

==== Persistence, program versions and the signature check

Imagine renaming, adding or deleting widgets in Glade:
an .ini file lying around from a previous program version, or an
entirely different user interface, would be not be able to restore the
state properly since variables and types might have changed.

GladeVCP detects this situation by a signature which depends on all
object names and types which are saved and to be restored. In the case
of signature mismatch, a new .ini file with default settings is
generated.

=== Using persistent variables

If you want any of Gtk widget state, HAL widgets output pin's values
and/or class attributes of your handler class to be retained across
invocations, proceed as follows:

 - import the +gladevcp.persistence+ module
 - decide which instance attributes, and their default values you want to
   have retained, if any
 - decide which widgets should have their state retained
 - describe these decisions in your handler class' +__init__()+ method
   through a nested dictionary as follows:

[source,python]
----------------------------------
def __init__(self, halcomp,builder,useropts):
    self.halcomp = halcomp
    self.builder = builder
    self.useropts = useropts
    self.defaults = {
        # the following names will be saved/restored as method attributes
        # the save/restore mechanism is strongly typed - the variables type will be derived from the type of the
        # initialization value. Currently supported types are: int, float, bool, string
        IniFile.vars : { 'nhits' : 0, 'a': 1.67, 'd': True ,'c' : "a string"},
        # to save/restore all widget's state which might remotely make sense, add this:
        IniFile.widgets : widget_defaults(builder.get_objects())
        # a sensible alternative might be to retain only all HAL output widgets' state:
        # IniFile.widgets: widget_defaults(select_widgets(self.builder.get_objects(), hal_only=True,output_only = True)),
    }
----------------------------------

Then associate an .ini file with this descriptor:

[source,python]
----------------------------------
self.ini_filename = __name__ + '.ini'
self.ini = IniFile(self.ini_filename,self.defaults,self.builder)
self.ini.restore_state(self)
----------------------------------

After `restore_state()`, self will have attributes set if as running the
following:

[source,python]
----------------------------------
self.nhits = 0
self.a = 1.67
self.d = True
self.c = "a string"
----------------------------------

Note that types are saved and preserved on restore. This example
assumes that the ini file didn't exist or had the default values from
self.defaults.

After this incantation, you can use the following IniFil methods:

ini.save_state(obj)::
	 saves objs's attributes as per IniFil.vars
	 dictionary and the widget state as described in IniFile.widgets in
	 self.defaults
ini.create_default_ini()::
	 create a .ini file with default values
ini.restore_state(obj)::
	restore HAL out pins and obj's attributes as
   	saved/initialized to default as above

To save the widget and/or variable state on exit, connect a signal
handler to the +window1+ (toplevel) destroy event:

[source,python]
----------------------------------
def on_destroy(self,obj,data=None):
    self.ini.save_state(self)
----------------------------------

Next time you start the GladeVCP application, the widgets should come
up in the state when the application was closed.

=== Hand-editing .ini files

You can do that, but note that the values in self.defaults override
your edits if there is a syntax or type error in your edit. The error
is detected, a console message will hint about that happened, and the
bad inifile will be renamed to have the .BAD suffix. Subsequent bad ini
files overwrite earlier .BAD files.

[[gladevcp:Adding_HAL_pins]]
=== Adding HAL pins

If you need HAL pins which are not associated with a specific HAL
widget, add them as follows:

[source,python]
----------------------------------
import hal_glib
...
# in your handler class __init__():
self.example_trigger = hal_glib.GPin(halcomp.newpin('example-trigger', hal.HAL_BIT, hal.HAL_IN))
----------------------------------

To get a callback when this pin's value changes, associate a
+value-change+ callback with this pin, add:

[source,python]
----------------------------------
self.example_trigger.connect('value-changed', self._on_example_trigger_change)
----------------------------------

and define a callback method (or function, in this case leave out the
+self+ parameter):

[source,python]
----------------------------------
# note '_' - this method will not be visible to the widget tree
def _on_example_trigger_change(self,pin,userdata=None):
    print "pin value changed to:" % (pin.get())
----------------------------------

=== Adding timers

Since GladeVCP uses Gtk widgets which rely on the
http://www.pygtk.org/pygtk2reference/gobject-functions.html[GObject]
base class, the full glib functionally is available. Here is an
example for a timer callback:

[source,python]
----------------------------------
def _on_timer_tick(self,userdata=None):
    ...
    return True # to restart the timer; return False for on-shot
...
# demonstrate a slow background timer - granularity is one second
# for a faster timer (granularity 1 ms), use this:
# glib.timeout_add(100, self._on_timer_tick,userdata) # 10Hz
glib.timeout_add_seconds(1, self._on_timer_tick)
----------------------------------

=== Examples, and rolling your own GladeVCP application

Visit +emc2/configs/gladevcp+ for running examples and starters for your own projects.


== FAQ

[qanda]
I get an unexpected unmap event in my handler function right after startup. What's this?::
   This is a consequence of your Glade UI file
   having the window1 Visible property set to True, together with
   re-parenting the GladeVCP window into Axis or touchy. The GladeVCP
   widget tree is created, including a top level window, and then
   'reparented into Axis', leaving that toplevel window laying around
   orphaned. To avoid having this useless empty window hanging around, it
   is unmapped (made invisible), which is the cause of the unmap signal
   you get. Suggested fix: set window1.visible to False, and ignore an
   initial unmap event.
My GladeVCP program starts, but no window appears where I expect it to be?::
   The window Axis allocates for GladeVCP will obtain the 'natural
   size' of all its child widgets combined. It's the child widget's job to
   request a size (width and/or height). However, not all widgets do
   request a width greater than 0, for instance the Graph widget in its
   current form. If there's such a widget in your Glade file and it's the
   one which defines the layout you might want to set its width
   explicitly. Note that setting the window1 width and height properties
   in Glade does not make sense because this window will be orphaned
   during re-parenting and hence its geometry will have no impact on
   layout (see above). The general rule is: if you manually run a UI file
   with 'gladevcp <uifile>' and its window has reasonable geometry, it
   should come up in Axis properly as well.

I want a blinking LED, so I ticked the checkbutton to let it blink with 100msec interval. 
It wont blink, and I get a startup warning: Warning: value "0" of type `gint' is 
invalid or out of range for property `led-blink-rate' of type `gint'?::
   This seems to be a glade bug. Just type over the blink rate field, and save again - this works for me.

My gladevcp panel in Axis doesnt save state when I close Axis,although I defined 
an on_destroy handler linked to the window destroy signal:: 
   Very likely this handler is linked to window1,
   which due to reparenting isnt usable for this purpose. Please link
   the on_destroy handler to the destroy signal of an interior
   window. For instance, I have a notebook inside window1, and linked
   on_destroy to the notebooks destroy signal, and that works fine. It
   doesnt work for window1.

// FIXME this is out of date
== Troubleshooting

 -  make sure your have the development version of EMC2 installed. You
   don't need the axisrc file any more, this was mentioned in the old
   GladeVcp wiki page.
 -  run GladeVCP or Axis from a terminal window. If you get Python errors,
   check whether there's still a +/usr/lib/python2.6/dist-packages/hal.so+
   file lying around besides the newer
   +/usr/lib/python2.6/dist-packages/_hal.so+ (note underscore); if yes,
   remove the +hal.so+ file. It has been superseded by hal.py in the same
   directory and  confuses the import mechanism.
 -  if you're using run-in-place, do a 'make clean' to remove any
   accidentally left over hal.so file, then 'make'.
 -  if you're using 'HAL_table' or 'HAL_HBox' widgets, be aware they have
   an HAL pin associated with it which is off by default. This pin
   controls whether these container's children are active or not.

== Implementation note: Key handling in Axis

We believe key handling works OK, but since it is new code, we're
telling about it you so you can watch out for problems; please let us
know of errors or odd behavior. This is the story:

Axis uses the TkInter widget set. GladeVCP applications use Gtk
widgets and run in a separate process context. They are hooked into
Axis with the Xembed protocol. This allows a child application like
GladeVCP to properly fit in a parent's window, and - in theory - have
integrated event handling.

However, this assumes that both parent and child application properly
support the Xembed protocol, which Gtk does, but TkInter doesn't. A
consequence of this is that certain keys would not be forwarded from a
GladeVCP panel to Axis properly under all circumstances. One of these
situations was the case when an Entry, or SpinButton widget had focus:
in this case, for instance an Escape key would not have been forwarded
to Axis and cause an abort as it should, with potentially disastrous
consequences.

Therefore, key events in GladeVCP are explicitly handled, and
selectively forwarded to Axis, to assure that such situations cannot
arise. For details, see the `keyboard_forward()` function in
`lib/python/gladevcp/xembed.py`.
