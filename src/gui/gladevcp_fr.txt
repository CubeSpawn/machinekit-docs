:lang: fr
:toc:

= L'outil de création d'interfaces graphiques GladeVCP

// TODO:
// - manual-example.ui layout - really bad
// - restructure faq/troubleshooting/notes section
// - check wiki vs docs
// - check other gladevcp docs branch against this


:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}
// begin a listing of ini/hal/ngc files like so:
//[source,{ini}]
//[source,{hal}]
//[source,{ngc}]

== Qu'est-ce que GladeVCP?

GladeVCP est un composant d'EMC2 qui donne la possibilité d'ajouter 
de nouvelles interfaces graphiques utilisateur à EMC2 telles qu'Axis ou Touchy. 
À la différence de PyVCP, GladeVCP n'est pas limité à l'affichage et aux
réglages des pins de HAL, toutes les actions peuvent être exécutées en code
Python. En fait, une interface utilisateur EMC2 complète peut être construite 
avec GladeVCP et Python.

GladeVCP utilise l'environnement graphique et WYSIWYG http://glade.gnome.org/[Glade] 
qui simplifie l'édition et la création visuelles de panneaux esthétiquement très
réussis. Il s'appuie sur les liaisons entre http://www.pygtk.org/[PyGTK] et le
riche jeu de widgets http://www.gtk.org/[GTK+], finalement, tous peuvent être 
utilisés dans une application GladeVCP et pas seulement les widgets spécialisés
pour interagir avec HAL et EMC2 présentés ici.

=== PyVCP par rapport à GladeVCP

Tous les deux supportent la création de panneaux avec des 'widgets de HAL', des 
éléments utilisateur visuels tels que boutons, Leds, curseurs etc. dont les 
valeurs sont liées à des pins de HAL qui à leur tour, sont des interfaces pour
le reste d'EMC2.

*PyVCP:*

 - Jeu de widgets: utilise les widgets TkInter.
 - Cycle de création d'interfaces utilisateur: "éditer les fichiers XML/ lancer / évaluer le look".
 - Pas de support pour intégrer une gestion des événements définie par l'utilisateur.
 - Pas d'interaction avec EMC2 au-delà des interactions avec les pins d'E/S de HAL supportées.

*GladeVCP:*

 - Jeu de widgets: Liaison avec le jeu de widgets de http://www.gtk.org/[GTK+].
 - Création d'interface utilisateur: utilise l'interface graphique http://glade.gnome.org/[Glade] 
   qui est un éditeur WYSIWYG.
 - Tout changement sur une pin de HAL peut diriger un appel vers une gestion d'événements 
   définie en Python par l'utilisateur.
 - Tous les signaux GTK (touches/appui sur un bouton, fenêtre, E/S, timer, événements réseau) 
   peuvent être associés avec la gestion d'événements définie en Python par l'utilisateur.
 - Interaction directe avec EMC2: exécution de commandes, telle qu'initialiser une
   commande MDI pour appeler un sous-programme G-code.
 - Plusieurs panneaux GladeVCP indépendants peuvent tourner dans des onglets différents.
 - Séparation entre l'apparence de l'interface et les fonctionnalités: change d'apparence 
   sans passer par aucun code.

== Description du fonctionnement, avec un exemple de panneau

Une fenêtre de panneau GladeVCP peut démarrer avec trois différentes configuration:

 - Toujours visible, intégré dans Axis, du côté droit, exactement comme un panneau PyVCP.
 - Dans un onglet dans Axis ou Touchy; dans Axis un troisième onglet sera créé
   à côté des deux d'origine, ils doivent être choisis explicitement.
 - Comme une fenêtre indépendante, qui peut être iconisée ou agrandie, 
   indépendamment de la fenêtre principale.

Lancer un panneau GladeVCP simple, intégré dans Axis comme PyVCP, taper les 
commandes suivantes:

*+$ cd configs/sim/gladevcp+*

*+$ emc gladevcp_panel.ini+*

image::images/example-panel-small.png[]

Lancer le même panneau, mais dans un onglet d'Axis:

*+$ cd configs/sim/gladevcp+*

*+$ emc gladevcp_tab.ini+*

image::images/example-tabbed-small.png[]

Pour lancer ce même panneau comme une fenêtre d'avant plan sur Axis, démarrer 
Axis en arrière plan puis démarrer gladevcp de la manière suivante:

*+$ cd configs/sim/gladevcp+*

*+$ emc axis.ini &+*

*+$ gladevcp -c gladevcp -u ../gladevcp/hitcounter.py -H ../gladevcp/manual-example.hal ../gladevcp/manual-example.ui+*

image::images/example-float-small.png[]

Pour lancer ce panneau dans 'Touchy':

*+$ cd configs/sim+*

*+$ emc gladevcp_touchy.ini+*

image::images/touchy-tab-33.png[]

Fonctionnellement, ces configurations sont identiques. La seule différence
porte sur l'état et la visibilité de l'écran. Puisqu'il est possible de lancer 
plusieurs composants GladeVCP en parallèle (avec des noms de modules 
de HAL différents), le mélange des configurations est également possible.
Par exemple, un panneau sur le côté droit et un ou plusieurs en onglets pour des
parties d'interface moins souvent utilisées.

=== Description de l'exemple de panneau

Pendant qu'Axis est en marche, explorons 'Afficher configuration de HAL' dans
lequel nous trouvons le composant de HAL 'gladevcp' et dont nous pouvons 
observer la valeur des pins pendant l'interaction avec les widgets du panneau. 
La configuration de HAL peut être trouvée dans 'configs/gladevcp/manual-example.hal'.

Usage des deux cadres en partie basse. Le panneau est configuré pour que, quand 
l'Arrêt d'Urgence est désactivé, le cadre 'Settings' s'active et mette la
machine en marche, ce qui active à son tour le cadre 'Commands' du dessous. 
Les widgets de HAL du cadre 'Settings' sont liés aux Leds et labels du cadre 
'Status' ainsi qu'au numéros de l'outil courant et à celui de l'outil préparé. 
Les utiliser pour bien voir leur effet. L'exécution des commandes 
'T<numéro d'outil>' et 'M6' dans la fenêtre du MDI aura pour effet de changer 
les numéros de l'outil courant et de l'outil préparé dans les champs respectifs.

Les boutons du cadre 'Commands' sont des 'widgets d'action MDI'. Les presser
exécutera une commande MDI dans l'interpréteur. Le troisième bouton 
'Execute Oword subroutine' est un exemple avancé, il prends plusieurs pins de HAL
du cadre 'Settings' et leur passe comme paramètres, le 'sous-programme Oword'. 
Les paramètres actuels reçus par la routine sont affichés par une commande
'(DEBUG, )'. Voir 'configs/gladevcp/nc_files/oword.ngc' pour le corps du
sous-programme.

Pour voir comment le panneau est intégré dans Axis, voir la déclaration de 
'[DISPLAY]GLADEVCP' dans gladevcp_panel.ui, ainsi que les déclarations de
'[DISPLAY]EMBED*' et de '[HAL]POSTGUI_HALFILE' dans 'gladevcp_tab.ini', 
respectivement.

=== Description de l'éditeur de Glade

L'interface utilisateur est créée avec l'éditeur graphique de Glade. Pour 
l'essayer il faut avoir le pré-requis nécessaire, <<gladevcp:Pre-requis,que glade soit installé>>. 
Pour éditer l'interface utilisateur, lancer la commande:

*+$ glade configs/gladevcp/manual-example.ui+*

La zone centrale de la fenêtre montre l'apparence de l'interface en création. 
Tous les objets de l'interface et les objets supportés se trouvent dans la partie
haute à droite de la fenêtre, où il est possible de choisir un widget spécifique
(ou en cliquant sur lui au centre de la fenêtre). Les propriétés du widget choisi
sont affichées et peuvent être modifiées, dans le bas à droite de la fenêtre.

Pour voir comment les commandes MDI sont passées depuis les widgets d'action MDI,
explorer la liste des widgets sous 'Actions' en haut à droite de la fenêtre,
et dans le bas à droite de la fenêtre, sous l'onglet 'Général', les propriétés
des 'commandes MDI'.

=== Explorer le callback de Python
Voici comment un callback Python est intégré dans l'exemple:

 - Dans glade, regarder le label du widget +hits+ (un widget GTK+).
 - Dans le widget +button1+, regarder dans l'onglet 'Signaux' et trouver le
   signal 'pressed' associé avec le gestionnaire 'on_button_press'.
 - Dans ../gladevcp/hitcounter.py, regarder la méthode 'on_button_press' 
   et comment elle place la propriété du label dans l'objet 'hits'.

C'était juste pour toucher le concept du doigt. Le mécanisme de callback sera
détaillé plus en détails dans la section <<gladevcp:GladeVCP_Programming,
Programmation de GladeVCP>>.

== Créer et intégrer une interface utilisateur Glade

[[gladevcp:Pre-requis]]
=== Pré-requis: Installation de Glade

Pour visualiser ou modifier les fichiers d'une interface Glade, Glade doit
être installé. Ce n'est pas nécessaire pour seulement essayer un panneau GladeVCP. 
Si la commande +*glade*+ est manquante, l'installer de la manière suivante:

*+$ sudo apt-get install glade+*

Vérifier ensuite la version installée, qui doit être égale ou supérieure à 3.6.7:

*+$ glade --version+*

*+glade3 3.6.7+*

=== Lancer Glade pour créer une nouvelle interface utilisateur
Cette section souligne juste les étapes initiales spécifiques à EMC2. Pour plus
d'informations et un tutoriel sur Glade, voir http://glade.gnome.org. Certains
trucs & astuces sur Glade, peuvent aussi être trouvés sur http://www.youtube.com[youtube].

Soit modifier une interface existante en lançant +glade <fichier>.ui+ ou,
démarrer une nouvelle en lançant juste la commande +glade+ depuis un terminal.

- Si EMC2 n'a pas été installé depuis un paquetage, l'environnement EMC2 du 
shell doit être configuré avec 
+. <emcdir>/scripts/emc-environment+, autrement Glade ne trouvera pas les widgets
spécifiques à EMC2.
- Quand l'éditeur demande pour enregistrer les préférences, accepter ce qui est
proposé par défaut et presser 'Close'.
- Depuis les 'Niveaux supérieurs' (cadre de gauche), choisir 'Fenêtre' (première icône) 
en haut des Niveaux supérieurs, par défaut cette fenêtre sera nommée 'window1'. 
Ne pas changer ce nom, GladeVCP lui est relié.
- Dans le bas des onglets de gauche, dérouler 'HAL Python' et 'EMC Actions'.
- Ajouter au nouveau cadre, un conteneur comme une boîte HAL_Box ou une 
HAL_Table depuis 'HAL Python'.
- Pointer et placer dans un conteneur d'autres éléments, comme une LED, un bouton, etc.

Le résultat pourrait ressembler à cela:

image::images/glade-manual-small.png[]

Glade a tendance à écrire beaucoup de messages dans la fenêtre du terminal, la
plupart peuvent être ignorés. Sélectionner 'Fichier->Enregistrer sous', donner lui
un nom comme 'myui.ui' et bien vérifier qu'il sera enregistré comme un fichier
'GtkBuilder' (bouton radio en bas à gauche du dialogue d'enregistrement). 
GladeVCP peut aussi traiter correctement l'ancien format 'libglade' mais il n'y 
a aucune raison de l'utiliser. Par convention, l'extension des fichier GtkBuilder 
est '.ui'.

=== Tester un panneau
Vous êtes maintenant prêt à faire un essai (avec EMC2, par exemple Axis en marche)
faites:

*+gladevcp myui.ui+*

GladeVCP crée le composant de HAL portant le nom qui a été donné au fichier, par 
exemple, le très original 'myui.ui' dans notre cas, à moins qu'il n'ait été 
surchargé pat l'option +-c <nom du composant>+. Si Axis est en marche, essayer 
de trouver le composant dans 'Afficher configuration de HAL' et inspecter ses pins.

Vous vous demandez peut être pourquoi les widgets conteneurs comme 'HAL_Hbox' ou
'HAL_Table' apparaissent grisés (inactifs). Les conteneurs HAL ont une pin de HAL
associée qui est désactivée par défaut, c'est ce qui cause ce rendu grisé des
widgets conteneurs inactifs. Un cas d'utilisation courante pourrait être pour
associer les pins de HAL du conteneur +halui.machine.is-on+ ou un des signaux
+halui.mode.+, pour s'assurer que certains widgets n'apparaissent actif que dans
un certain état.

Pour activer un conteneur, exécuter la commande HAL +setp gladevcp.<nom-du-conteneur> 1+.

=== Préparer le fichier de commande HAL
La voie suggérée pour lier les pins de HAL dans un panneau GladeVCP consiste à
les collecter dans un fichier séparé portant l'extension +.hal+. Ce fichier est
passé via l'option +POSTGUI_HALFILE=+, dans la section +[HAL]+ du fichier de
configuration.

ATTENTION: Ne pas ajouter le fichier de commandes HAL de GladeVCP à la section
ini d'Axis +[HAL]HALFILE=+, ça n'aurait pas l'effet souhaité. Voir les sections
suivantes.

=== Intégration dans Axis, comme pour PyVCP

Pour placer le panneau GladeVCP dans la partie droite d'Axis, ajouter les lignes
suivantes dans le fichier ini:

[source,{ini}]
----
[DISPLAY]
# ajouter le panneau GladeVCP à l'emplacement de PyVCP:
GLADEVCP= -u ../gladevcp/hitcounter.py ../gladevcp/manual-example.ui

[HAL]
# Les commandes HAL pour les composants GladeVCP dans un onglet, doivent être 
exécutées via POSTGUI_HALFILE
POSTGUI_HALFILE =  ../gladevcp/manual-example.hal

[RS274NGC]
# les sous-programmes Oword spécifiques à gladevcp se placent ici
SUBROUTINE_PATH = ../gladevcp/nc_files/
----

Le nom de composant HAL d'une application GladeVCP lancé avec l'option GLADEVCP 
est toujours: +gladevcp+.
La ligne de commande actuellement lancée par Axis dans la configuration ci-dessous
est la suivante:

 halcmd loadusr -Wn gladevcp gladevcp -c gladevcp -x {XID} <arguments pour GLADEVCP=>

Ce qui veux dire que n'importe quelle option gladevcp, peut être ajoutée ici, tant 
qu'elle n'entre pas en collision avec les options des lignes de commande suivantes.

[NOTE]
L'option +[RS274NGC]SUBROUTINE_PATH=+ est fixée seulement pour que l'exemple de
panneau puisse trouver le sous-programme Oword pour le widget de commande MDI. Il
n'est peut être pas nécessaire dans votre configuration.

=== Intégration dans un nouvel onglet d'Axis, à la suite des autres

Pour cela, éditer le fichier .ini et ajouter dans les sections DISPLAY et HAL,
les lignes suivantes:
[source,{ini}]
----
[DISPLAY]
# ajoute le panneau GladeVCP dans un nouvel onglet:
EMBED_TAB_NAME=GladeVCP demo
EMBED_TAB_COMMAND=halcmd loadusr -Wn gladevcp gladevcp -c gladevcp -x {XID} -u ../gladevcp/hitcounter.py ../gladevcp/manual-example.ui

[HAL]
# commandes HAL pour le composant GladeVCP dans un onglet doit être exécuté via POSTGUI_HALFILE
POSTGUI_HALFILE =  ../gladevcp/manual-example.hal

[RS274NGC]
# les sous-programmes Oword spécifiques à gladevcp se placent ici
SUBROUTINE_PATH = ../gladevcp/nc_files/
----

Noter le 'halcmd loadusr' pour charger la commande d'onglet, elle assure que
'POSTGUI_HALFILE' ne sera lancé que seulement après que le composant de HAL ne soit 
prêt. Dans de rares cas, une commande pourrait être lancée ici, pour utiliser 
un onglet sans être associée à un composant de HAL. Une telle commande pourrait 
être lancée sans 'halcmd loadusr', ce qui indiquerait à Axis qu'il ne doit plus 
attendre un composant de HAL, puisqu'il n'existe pas.

Noter que quand le nom du composant est changé dans l'exemple suivant, les noms 
utilisés dans +-Wn <composant>+ et +-c <composant>+ doivent être identiques.

Essayer en lançant Axis, il doit avoir un nouvel onglet appelé 'GladeVCP demo' 
à droite de l'onglet de la visu. Sélectionner cet onglet, le panneau de l'exemple
devrait être visible, bien intégré à Axis.

[NOTE]
Bien vérifier que le fichier de l'interface est la dernière option passée à 
GladeVCP dans les deux déclarations +GLADEVCP=+ et +EMBED_TAB_COMMAND=+.

=== Intégration dans Touchy
Pour ajouter un onglet GladeVCP à 'Touchy', éditer le fichier .ini comme cela:
[source,{ini}]
-------------------------------------------------------
[DISPLAY]
# ajoute un panneau GladeVCP dans un onglet
EMBED_TAB_NAME=GladeVCP demo
EMBED_TAB_COMMAND=gladevcp -c gladevcp -x {XID} -u ../gladevcp/hitcounter.py -H ../gladevcp/gladevcp-touchy.hal  ../gladevcp/manual-example.ui

[RS274NGC]
# les sous-programmes Oword spécifiques à gladevcp se placent ici
SUBROUTINE_PATH = ../gladevcp/nc_files/
-------------------------------------------------------

Noter les différences suivantes avec la configuration de l'onglet d'Axis:

 - Le fichier de commandes HAL est légèrement modifié puisque 'Touchy' n'utilise
   pas le composant 'halui', ses signaux ne sont donc pas disponibles et certains
   raccourcis ont été pris.

 - Il n'y a pas d'option 'POSTGUI_HALFILE=', mais il est correct, de passer le 
   fichier de commandes HAL, par la ligne 'EMBED_TAB_COMMAND='.

 - L'appel 'halcmd loaduser -Wn ...' n'est pas nécessaire.

== Options de GladeVCP en ligne de commande

Voir également, 'man gladevcp'. Ce sont les options pour cette ligne de 
commande:

Usage: gladevcp [options] myfile.ui

Options:

-h, --help::
    Affiche ce message d'aide et sort.

-c NAME::
    Fixe le nom du composant à NAME. Par défaut, le nom de base des fichiers UI

-d::
    Active la sortie débogage

-g GEOMETRY::
     Fixe la géométrie à WIDTHxHEIGHT+XOFFSET+YOFFSET. Les valueurs sont en pixels,
    XOFFSET/YOFFSET est référencé à partir du coin haut, à gauche de l'écran.
    Utilise -g WIDTHxHEIGHT pour fixer une taille ou -g +XOFFSET+YOFFSET pour 
    fixer une position 

-H FILE::
    exécute les déclarations de HAL depuis FILE, avec halcmd après que le composant 
    soit chargé et prêt

-m MAXIMUM::
    force la fenêtre du panneau à se maximiser. Toutefois avec l'option -g geometry 
    le panneau est déplaçable d'un moniteur à un autre en le forçant à utiliser 
    toute l'écran

-t THEME::
    fixe le thème gtk. Par défaut, le thème système. Différents panneaux peuvent
    avoir différents thèmes.
    Un exemple de thème peut être trouvé sur le http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?GTK_Themes[Wiki d'EMC2].

-x XID::
    Redonne un parent GladeVCP dans une fenêtre existante XID au lieu d'en 
    créer une nouvelle au niveau supérieur

-u FILE::
    Utilise les FILE comme modules définis par l'utilisateur avec le gestionnaire

-U USEROPT::
    passe les modules python USEROPT

== Références des Widgets HAL

GladeVcp inclus une collection de widgets Gtk qui ont des pins de HAL attachées,
appelés widgets HAL, il sont destinés à contrôler, à afficher et à avoir d'autres
interactions avec la couche HAL d'EMC. Il sont destinés à être utilisés avec les 
interfaces créées par l'éditeur de Glade. Avec une installation correcte, les 
widgets HAL devraient être visibles, dans l'éditeur Glade, dans le groupe des 
Widgets 'HAL Python'. Beaucoup de champs spécifiques à HAL dans l'onglet 'Général'
affichent une bulle d'information au survol de la souris.

Il y a deux variantes de signaux de HAL, bits et nombres. Les signaux
bits sont les on/off. Les nombres peuvent être des "float", des "s32" ou
des "u32". Pour plus d'informations sur les types de données de HAL, 
voir le manuel de HAL. Les widgets GladeVcp peuvent soit, 
afficher la valeur d'un signal avec un widget d'indication, soit, modifier la 
valeur d'un signal avec un widget de contrôle. Ainsi, il existe quatre classes 
de widgets gladvcp qui peuvent être connectés à un signal de HAL. Une autre 
classe de widgets d'aide permettent d'organiser et d'étiqueter les panneaux.

 - Widgets d'indications "bit" signals: <<gladevcp:HAL_LED,Led HAL>>
 - Widgets de contrôle "bit" signals: <<gladevcp:HAL_Button,HAL Bouton>>,
   <<gladevcp:HAL_Button,HAL Bouton radio>>,
   <<gladevcp:HAL_Button,HAL Case à cocher>>
 - Widgets d'indications "nombre" signals: <<gladevcp:HAL_Label>>,
   <<gladevcp:HAL_ProgressBar,HAL Barre de progression>>,
   <<gladevcp:HAL_HBar,HAL HBar>>, <<gladevcp:HAL_HBar,HAL VBar>>,
   <<gladevcp:HAL_Meter,HAL Indicateur à aiguille>>
 - Widgets de contrôle "nombre" signals: <<gladevcp:HAL_SpinButton,Roue codeuse>>,
   <<gladevcp:HAL_HScale,HAL HScale>>,
   <<gladevcp:HAL_HScale,HAL VScale>>
 - widgets d'aide: <<gladevcp:HAL_HBox,HAL Table>>, <<gladevcp:HAL_HBox,HAL HBox>>
 - Tracé du parcours d'outil: <<gladevcp:HAL_Gremlin,HAL Gremlin>>

Les widgets HAL héritent des méthodes, propriétés et signaux des widgets Gtk 
sous-jacents, il est donc utile de consulter le site du http://www.gtk.org/[GTK+] 
ainsi que la documentation pour les liaisons avec http://www.pygtk.org/[PyGTK].

=== Nommage des Widgets HAL et de leurs pins

La plupart des widgets HAL on une simple pin de HAL associée et portant le même 
nom que le widget (glade: Général->Nom).

Les exceptions à cette règle sont actuellement:

- 'HAL_Spinbutton' et 'HAL_ComboBox', qui ont deux pins: une pin 
   +<nomwidget>-f+ (float) et une pin +<nomwidget>-s+ (s32)
- 'HAL_ProgressBar', qui a une pin d'entrée +<nomwidget>-value+, et une pin 
d'entrée +<nomwidget>-scale+.

=== Donner des valeurs aux Widgets HAL et à leurs pins

En règle générale, si une valeur doit être attribuée à la sortie d'un widget HAL
depuis un code Python, le faire en appelant le 'setter' Gtk sous-jacent (par
exemple +set_active()+, +set_value()+), ne pas essayer de donner directement la 
valeur à la pin associée par un +halcomp[nompin] = value+, parce-que le widget
ne verra jamais le changement!.

Il pourrait être tentant de 'fixer une pin d'entrée de widget HAL' par programme.
Noter que cela va à l'encontre du but premier d'une pin d'entrée. Elle devrait 
être attachée à un autre composant de HAL et réagir au signal qu'il génère. Bien
qu'aucune protection, empêchant d'écrire sur les pins d'entrée HAL Python, ne soit 
présente actuellement, cela n'aurait aucun sens. Il faut utiliser +setp nompin valeur+
dans un fichier Hal associé, pour les essais.

Il est par contre, parfaitement autorisé de mettre une valeur sur une pin de 
sortie de Hal avec +halcomp[nompin] = valeur+ à condition que cette pin ne soit
pas déjà associée avec un autre widget, ce qui aurait pu être créé par la méthode 
+hal_glib.GPin(halcomp.newpin(<nom>,<type>,<direction>)+. Voir <<gladevcp:GladeVCP_Programming,Programmation de GladeVCP>> pour d'autres exemples.

[[gladevcp::hal-pin-changed_signal]]
=== Le signal 'hal-pin-changed'

La programmation événementielle signifie que l'interface graphique indique au 
code quand "quelque chose se produit", grâce à un callback, comme quand un 
bouton est pressé, la sortie du widget HAL (ceux qui affichent la valeur des pins 
de HAL) comme une LED, une barre, une VBar, un indicateur à aiguille etc, 
supportent le signal 'hal-pin-changed' qui peut provoquer un callback dans le 
code Python quand une pin de HAL change de valeur. Cela veut dire qu'il n'est 
plus nécessaire d'interroger en permanence les pins de HAL dans le code pour 
connaitre les changements, les widgets font ça en arrière plan et le font savoir.

Voici un exemple montrant comment régler un signal +hal-pin-changed+ pour
une Hal Led, dans l'éditeur de Glade:

image::images/hal-pin-change-66.png[]
L'exemple dans +configs/gladevcp/examples/complex+ montre comment c'est géré 
en Python.

[[gladevcp:HAL_Button]]
=== Les boutons (HAL Button)

Ce groupe de widgets est dérivé de divers boutons Gtk, ce sont les widgets
HAL_Button, HAL_ToggleButton, HAL_RadioButton et CheckButton. Tous ont une seule
pin de sortie BIT portant un nom identique au widget. Les boutons n'ont pas d'autres
propriétés additionnelles, contrairement à leurs classes de base Gtk.

 - HAL_Button: Action instantanée, ne retient pas l'état. 
   Signal important: +pressed+.
 - HAL_ToggleButton, HAL_CheckButton: Retiennent l'état on/off. 
   Signal important: +toggled+.
 - HAL_RadioButton: Un parmi un groupe. Signal important: +toggled+ (par bouton).
 - Importantes méthodes communes: +set_active()+, +get_active()+
 - Importantes propriétés: +label+, +image+


// .Boutons
Case à cocher:
image:images/checkbutton.png[]
Boutons radio:
image:images/radiobutton.png[]
Bouton à bascule:
image:images/button.png[]


[TIP]
====
Définir les groupes de boutons radio dans Glade:

- Décider du bouton actif par défaut

- Dans les boutons radio, 'Général->Groupe' sélectionner le nom du bouton actif 
  par défaut dans le dialogue 'Choisir un Bouton radio pour ce projet'.

Voir +configs/gladevcp/by-widget/radiobutton+ pour une application GladeVCP avec 
un fichier d'interface utilisateur, pour travailler sur les boutons radio.
====

[[gladevcp:HAL_VScale]]

[[gladevcp:HAL_HScale]]
=== Les échelles (Scales)

HAL_HScale et HAL_VScale sont respectivement dérivées de GtkHScale et GtkVScale. 
Elles ont une pin de sortie FLOAT portant le même nom que le widget. Les échelles
n'ont pas de propriété additionnelle.

Pour créer une échelle fonctionnelle dans Glade, ajouter un 'Ajustement'
(Général->Ajustement->Nouveau ou existant) et éditer l'objet ajustement. Il défini
les valeurs défaut/min/max/incrément. Fixer la 'Sensibilité de l'incrément' de 
l'ajustement sur automatique pour éviter les warnings.

Exemple d'échelle (HAL_hscale):
image:images/hscale.png[]
.

[[gladevcp:HAL_SpinButton]]
=== La roue codeuse (SpinButton)

La roue codeuse de HAL est dérivée de GtkSpinButton, elle a deux pins de sortie:

<nomwidget>-f::
	 out FLOAT pin
<nomwidget>-s::
	 out S32 pin

Pour être fonctionnelle, Spinbutton doit avoir une valeur d'ajustement comme 
l'échelle, vue précédemment.

Exemple de roue codeuse:
image:images/spinbutton.png[]


[[gladevcp:HAL_Label]]
=== Les labels

Le Label HAL est un simple widget basé sur GtkLabel qui représente la valeur 
d'une pin de HAL dans un format défini par l'utilisateur.

HAL pin type::
	Les pins de HAL sont des types (0:S32, 1:float ou 2:U32), voir aussi la bulle
    d'info sur 'Général->HAL pin type', (noter que c'est différent de PyVCP qui
    lui, a trois widgets label, un pour chaque type).

text template::
	Détermine le texte à afficher, une chaine au format Python pour convertir
	la valeur de la pin en texte. Par défauts, à +%s+ (les valeurs sont 
	converties par la fonction str()), mais peut contenir n'importe quel argument
    légal pour la méthode format() de Python.
	Exemple: +Distance: %.03f+ va afficher le texte et la valeur de la pin avec
    3 digits fractionnaires remplis avec des zéros pour une pin FLOAT.


[[gladevcp:HAL_Table]]

[[gladevcp:HAL_HBox]]
=== Les conteneurs: HAL_HBox et HAL_Table

Comparés à leurs contreparties Gtk ils ont une pin d'entrée BIT qui contrôle si
les enfants des widgets sont sensitifs ou non. Si la pin est basse, alors 
les widgets enfants sont inactifs, ce qui est le comportement par défaut.

[TIP]
Si vous trouvez que certaines parties de votre application GladeVCP sont 'grisées' 
(insensible), vérifiez que les pins d'un conteneur ne soient pas inutilisées.

[[gladevcp:HAL_LED]]
=== Les Leds

La Led hal simule un vrai indicateur à Led. Elle a une seule pin d'entrée BIT
qui contrôle son état: ON ou OFF. Les Leds ont quelques propriétés pour
contrôler leur aspect:

on_color::
   Une chaine définissant la couleur ON de la Led. Peut être tout nom valide de
   gtk.gdk.Color. Ne fonctionne pas sous Ubuntu 8.04.
off_color::
   Un chaine définissant la couleur OFF de la Led. Peut être tout nom valide de
   gtk.gdk.Color ou la valeur spéciale `dark`. `dark` signifie que la couleur OFF
   sera fixée à 0.4 valeur de la couleur ON. Ne fonctionne pas sous Ubuntu 8.04.
pick_color_on, pick_color_off::
   Couleurs pour les états ON et OFF peuvent être représentées par une chaine
   comme `#RRRRGGGGBBBB`. Ces propriétés optionnelles ont la précédence sur 
   `on_color` et `off_color`.
led_size::
   Rayon de la Led (pour une Led carrée, 1/2 côté)
led_shape::
   Forme de la Led Shape. Les valeurs permises sont 0 pour ronde, 1 pour ovale
   et 2 pour carrée.
led_blink_rate::
   Si utilisée et que la Led est ON, alors la Led clignotera. La fréquence du
   clignotement est égal à la valeur de "led_blink_rate", spécifiée en millisecondes.

Comme un widget d'entrée, la Led aussi supporte le +hal-pin-changed signal+. Si
vous voulez avoir une notification dans votre code quand les pins des Leds HAL
ont changé d'état, alors connectez ce signal au gestionnaire, par exemple
+on_led_pin_changed+ et passez ce qui suit au gestionnaire:

[source,python]
----
def on_led_pin_changed(self,hal_led,data=None):
    print "on_led_pin_changed() - HAL pin value:",hal_led.hal_pin.get()
----

Ce code sera appelé à chaque front du signal et également au démarrage du programme
pour reporter la valeur courante.

Exemple de Leds:
image:images/leds.png[]

[[gladevcp:HAL_ProgressBar]]
=== La barre de progression (ProgressBar)

[NOTE]
Ce widget pourrait disparaître. Utilisez les widgets HAL_HBar et HAL_VBar à sa
place.

La HAL_ProgressBar est dérivée de gtk.ProgressBar et a deux pins d'entrée de HAL float:

<nomwidget>::
	la valeur courante à afficher.
<nomwidget>-scale::
	la valeur maximum absolue en entrée.

Elle a les propriétés suivantes:

scale::
	Valeur d'échelle. fixe la valeur maximum absolue en entrée. Pareil que la 
    configuration de la pin <nomwidget>.scale. Un flottant, compris entre
	*-2^24^* et *+2^24^*.
green_limit::
      Limite basse de la zone verte
yellow_limit::
      Limite basse de la zone jaune
red_limit::
      Limite basse de la zone rouge
text_template::
      Texte modèle pour afficher la valeur courante de la pin +<nomwidget>+. 
      Formaté pour Python, peut être utilisé pour dict +{"valeur":valeur}+.

Exemple de barre de progression:
image:images/progressbar2.png[]


[[gladevcp:HAL_ComboBox]]
=== La boîte combinée (ComboBox)

La comboBox HAL est dérivée de gtk.ComboBox. Elle valide le choix d'une valeur 
dans une liste déroulante.

Elle exporte deux pins de HAL:

 <nomwidget>-f::
		  La valeur courante, de type FLOAT
 <nomwidget>-s::
		  La valeur courante, de type S32

Elle a la propriété suivante, qui est configurable dans Glade:

column::
	 L'index de colonne, type S32, défaut à -1, échelle de -1 à 100.

En mode par défaut, ces réglages du widget mettent les pins à la valeur d'index 
de l'entrée choisie dans la liste. Aussi, si le widget a trois labels, il peut
seulement assumer les valeurs 0, 1 et 2.

En mode colonne (colonne > -1), la valeur reportée est choisie dans le tableau
de stockage de liste défini dans Glade. Ainsi, typiquement la définition du
widget devrait comprendre deux colonnes dans le tableau de stockage, une avec
le texte affiché dans la liste déroulante, l'autre une valeur entière ou flottante
correspondante au choix.

Il y a un exemple dans
+configs/gladevcp/by-widget/combobox/combobox.{py,ui}+ qui utilise le mode 
colonne pour prendre une valeur flottante dans un stockage de liste.

Si comme moi, vous êtes désorienté pour éditer une liste de stockage de ComboBox
ou de CellRenderer, voyez http://www.youtube.com/watch?v=Z5_F-rW2cL8.

[[gladevcp:HAL_VBar]]

[[gladevcp:HAL_HBar]]
=== Les barres

Les widgets HAL, HBar et VBar pour barres Horizontale et Verticale, représentent
des valeurs flottantes. Elles ont une pin d'entrée de HAL FLOAT. Chaque barre a
les propriétés suivantes:

invert::
   Inverse les directions min avec max. Une HBar inversée croît de la droite 
   vers la gauche, un VBar inversée croît du haut vers le bas.
min, max::
   Valeurs minimum et maximum de l'étendue souhaitée. Ce n'est pas une erreur si
   la valeur courante dépasse cette étendue.
zero::
   Point le plus bas de l'étendue. Si il est entre min et max, alors la barre
   croît à partir de cette valeur et non de la gauche du widget (ou de sa droite). 
   Utile pour représenter des valeurs qui peuvent être à la fois, positives ou
   négatives.
force_width, force_height::
   Force la largeur ou la hauteur du widget. Si inutilisés, la taille sera déduite
   du conteneur ou de la taille des widgets et des barres qui remplissent la zone.
text_template::
   Détermine le texte à afficher, comme pour le Label, pour les valeurs 
   min/max/courante. Peut être utilisé pour arrêter l'affichage de la valeur.
bg_color::
   Couleur de fond pour la barre (inactive).
z0_color, z1_color, z2_color::
   Couleurs des zones des différentes valeurs.
   Par défaut, `green`, `yellow` et `red`. Pour une description des zones voir
   propriétés des `z*_border`.
z0_border, z1_border::
   Définissent les limites des zones de couleur. Par défaut, seule une zone est validée. 
   Pour en activer plus d'une, fixer `z0_border` et `z1_border` aux valeurs
   souhaitées. Ainsi, zone 0 va remplir depuis 0 à la première bordure, zone 1 va
   remplir de la première à la seconde bordure et zone 2 depuis la dernière bordure
   jusqu'à 1. Les bordures se règlent comme des fractions, les valeurs vont de 0 à 1.

Barre horizontale:
image:images/hal_hbar.png[]
Barre verticale:
image:images/vscale.png[]
.

[[gladevcp:HAL_Meter]]
=== L'indicateur à aiguille (HAL Meter)

L'indicateur à aiguille (HAL Meter) est un widget similaire à celui de PyVCP, 
il représente une valeur flottante et a une pin d'entrée de HAL FLOAT. 
L'indicateur à aiguille a les deux propriétés suivantes:

min, max::
   Valeurs minimum et maximum de l'étendue souhaitée. Ce n'est pas une erreur si
   la valeur courante dépasse cette étendue.
force_size::
   Force le diamètre du widget. Si inutilisé, alors la taille sera déduite du
   conteneur ou des dimensions d'un widget à taille fixe. L'indicateur à aiguille
   occupera alors l'espace le plus grand disponible, tout en respectant les
   proportions.
text_template::
   Détermine le texte à afficher, comme pour le Label, pour la valeur 
   courante. Peut être utilisé pour arrêter l'affichage de la valeur.
label::
   Label large au dessus du centre de l'indicateur.
sublabel::
   Petit label, sous le centre de l'indicateur.
bg_color::
   Couleur de fond de l'indicateur.
z0_color, z1_color, z2_color::
   Valeurs des couleurs des différentes zones. Par défaut, `green`, `yellow` et `red`. 
   For description of
   zones see `z*_border` properties.
z0_border, z1_border::
   Définissent les limites externes des zones de couleur. Par défaut, une seule zone 
   de couleur est définie. Pour en activer plus d'une, fixer `z0_border` et 
   `z1_border` aux valeurs souhaitées. Ainsi, zone 0 va remplir depuis min à la 
   première bordure, zone 1 va remplir de la première à la seconde bordure et 
   zone 2 depuis la dernière bordure jusqu'à max. Les bordures se règlent sur une
   étendue comprise en min et max.

Exemples d'indicateurs à aiguille:

image::images/hal_meter.png[]
.

[[gladevcp:HAL_Gremlin]]
===  Gremlin, visualiseur de parcours d'outil pour fichiers .ngc

Gremlin est un traceur de parcours d'outil similaire à celui d'Axis.
Il demande un environnement EMC en fonctionnement, comme Axis ou Touchy. 
Pour se connecter à lui, inspecter la variable d'environnement INI_FILE_NAME. 
Gremlin affiche le fichiers .ngc courant. Si le fichier ngc est modifié,
il doit être rechargé pour actualiser le tracé. Si il est lancé dans une application
GladeVCP quand EMC n'est pas en marche, un message va être affiché parce-que 
le widget Gremlin ne trouve pas le statut d'EMC, comme le nom du fichier courant.

Gremlin n'exporte aucune pin de HAL. Il a les propriétés suivantes:

view ::
   Peut être la vue en `x`, `y`, `z`, `p` (perspective) . Par défaut, vue en `z`.
enable_dro ::
   Booléen; afficher une visu sur le tracé ou non.
   Par défaut,à `True`.

Exemple:

image::images/gremlin.png[]


=== Fonction de diagrammes animés: Widgets HAL dans un bitmap

Pour certaines applications, il est intéressant d'avoir une image de fond,
comme un diagramme fonctionnel et positionner les widgets aux endroits appropriés
dans le diagramme. Une bonne combinaison consiste à placer une image de fond 
comme un fichier .png, mettre la fenêtre GladeVCP en taille fixe, et utiliser
Glade pour fixer la postion du widget sur cette image.

Le code pour l'exemple ci-dessus peut être trouvé dans +configs/gladevcp/animated-backdrop+:

image::images/small-screenshot.png[]

== Références des Widgets EMC Action

GladeVcp inclus une collection d'actions préprogrammées appelées widgets `EMC Action`
qui sont des Widgets pour l'éditeur Glade. À la différence des widgets HAL,
qui interagissent avec les pins de HAL, les widgets EMC Actions, interagissent 
avec EMC et son interpréteur de G-code.

Les widgets EMC Action sont dérivés du widget Gtk.Action. Le widget EMC Action
en quelques mots:

 - C'est un objet disponible dans l'éditeur Glade.
 - Il n'a pas d'apparence visuelle par lui-même.
 - Son but: associer à un composant d'interface visible, à un composant 
   d'interface sensitif, comme un menu, un bouton outil, un bouton avec une
   commande. Voir les propriétés des widgets Action dans 'Général->Related
   Action' de l'éditeur.
 - L'action préprogrammée sera exécutée quand l'état du composant associé basculera
   (bouton pressé, menu cliqué...)
 - Ils fournissent une voie facile pour exécuter des commandes sans avoir à faire
   appel à la programmation en Python.

L'apparence des EMC Actions dans Glade est approximativement la suivante:

image::images/emc-actions.png[]

Le survol de la souris donne une description.

=== Les widgets EMC Action

Les widgets EMC Action sont des widgets de type 'un seul coup'. Ils implémentent
une seule action par l'usage, d'un seul bouton, d'une option de menu, d'un 
bouton radio ou d'une case à cocher.

=== Les widgets EMC bascule action (ToggleAction)

Ce sont des widgets double état. Ils implémentent deux actions ou utilisent un
second état (habituellement, 'pressé') pour indiquer qu'une action est actuellement
en cours. Les bascules action sont prévues pour être utilisées avec les boutons
bascule (ToggleButtons) et les boutons bascule d'outil (ToggleToolButtons) ou 
encore, pour basculer les items de menu. Un exemple simple est le bouton bascule
d'Arrêt d'Urgence (EStop).

Actuellement, les widgets suivants sont disponibles:

 - La bascule `d'Arrêt d'Urgence` (ESTOP) envoie la commande ESTOP ou ESTOP_RESET 
   à EMC, selon l'état courant.
 - La bascule `ON/OFF` envoie la commande STATE_ON ou STATE_OFF.
 - La bascule `Pause/Reprise` envoie la commande AUTO_PAUSE ou AUTO_RESUME.

Les bascules action suivantes ont seulement une commande associée et utilisent
l'état 'pressé' pour indiquer que l'opération demandée est lancée:

 - La bascule `Run` envoie la commande AUTO_RUN et attends dans l'état pressé
   jusqu'à ce que l'interpréteur soit de nouveau au repos.
 - La bascule `Stop` est inactive jusqu'à ce que l'interpréteur passe à l'état actif
   (Un G-code est lancé) et permet alors à l'utilisateur d'envoyer la commande
   AUTO_ABORT.
 - La bascule `MDI` envoie la commande passée dans le MDI et attends sa complétion
   dans l'état inactif 'pressé'.

=== La bascule Action_MDI et les widgets Action_MDI

Ces widgets fournissent le moyen d'exécuter des commandes MDI. Le widget Action_MDI 
n'attends pas la complétion de la commande, comme le fait la bascule Action_MDI,
qui reste elle, désactivée tant que la commande n'est pas terminée.

=== Un exemple simple: Exécuter une commande MDI lors de l'appui sur un bouton.

+configs/gladevcp/mdi-command-example/whoareyou.ui+ est un fichier UI Glade qui
transmet cette action basique:

L'ouvrir dans Glade et étudier comment il est fait. Lancer Axis puis dans un 
terminal faire: `gladevcp whoareyou.ui`. Voir l'action +hal_action_mdi1+ et les
propriétés de +MDI command+ qui exécute juste +(MSG, "Hi, I'm an EMC_Action_MDI")+ 
ce qui ouvre un popup de message dans Axis, comme ci-dessous:

image::images/whoareyou.png[]

Noter que le bouton, associé à l'Action_MDI, est grisé si la machine est arrêtée, 
en A/U ou si l'interpréteur est déjà en marche. Il deviendra automatiquement actif
quand la machine sera mise en marche donc, sortie de l'A/U (E-Stop), et que le
programme est au repos.

=== Paramètres passés avec les widgets Action_MDI et ToggleAction_MDI

Optionnellement, la chaine 'MDI command' peut avoir des paramètres substitués
avant d'être passée à l'interpréteur. Ces paramètres sont actuellement les noms
des pins de HAL dans les composants GladeVCP. Voici comment cela fonctionne:

 - Supposons que nous avons une 'SpinBox HAL' nommée +speed+, nous voulons passer
   sa valeur courante comme paramètre dans une commande MDI.
 - La SpinBox HAL aura une pin de HAL de type flottant, nommée speed-f (voir
   la description des Widgets Hal).
 - Pour substituer cette valeur dans la commande MDI, insérons le nom de la pin de HAL
   encadré de cette manière: `${pin-name}`
 - Pour la spinbox HAL précédente, il aurait été possible d'utiliser
   `(MSG, "La vitesse est: ${speed-f}")` juste pour montrer ce qui se passe.

L'exemple de fichier UI est +configs/gladevcp/mdi-command-example/speed.ui+. 
Voici ce qui ce qui est obtenu en le lançant:

image::images/speed.png[]

=== Un exemple plus avancé: Passer des paramètres à un sous-programme O-word

Il est parfaitement permis d'appeler un sous-programme O-word dans une commande
MDI et passer la valeur des pins de HAL comme paramètres actuels. Un exemple de
 fichier UI est dans +configs/gladevcp/mdi-command-example/owordsub.ui+.

Placer +configs/gladevcp/nc_files/oword.ngc+ de sorte qu'Axis puisse le trouver,
et lancer `gladevcp owordsub.ui` depuis un terminal. Ce qui devrait ressembler à celà:

image::images/oword.png[]

=== Préparation pour une Action_MDI et nettoyage par la suite

L'interpréteur de G-code d'EMC a un simple jeu de variables globales, comme
vitesse, vitesse broche, mode relatif/absolu et autres. Si on utilise des commandes
G-code ou des sous-programmes O-word, certaines de ces variables doivent être
modifiées par la commande ou le sous-programme. Par exemple, un sous-programme
de sonde a très probablement besoin de définir la vitesse d'avance à une valeur
très faible. Sans autres précautions, le réglage de vitesse précédent serait 
écrasé par la valeur du sous-programme de sonde.

Pour faire avec ce surprenant, autant qu'indésirable effet de bord, produit par 
un sous-programme O-word ou un G-code exécuté avec une bascule Action MDI, 
le gestionnaire pré-MDI et post-MDI doit être associé avec une EMC bascule Action_MDI
donnée. Ces gestionnaires sont optionnels et fournissent une voie pour sauver tous 
les états avant d'exécuter l'action MDI et pour les restaurer ensuite aux valeurs 
précédentes. Les noms de signaux sont +mdi-command-start+ et +mdi-command-stop+,
les noms de gestionnaires peuvent être fixés dans Glade comme tout autre gestionnaire.

Voici un exemple, montrant comment la valeur de la vitesse d'avance est sauvée
 et restaurée par de tels gestionnaires, noter que la commande EMC et le statut 
des voies sont disponibles comme +self.emc+ et +self.stat+ à travers la classe
EMC_ActionBase:

[source,python]
----
    def on_mdi_command_start(self, action, userdata=None):
        action.stat.poll()
        self.start_feed = action.stat.settings[1]
    
    def on_mdi_command_stop(self, action, userdata=None):
        action.emc.mdi('F%.1f' % (self.start_feed))
        while action.emc.wait_complete() == -1:
            pass
----

Seule le widget de la bascule Action_MDI, supporte ces signaux.

[NOTE]
Dans une prochaine version d'EMC2, les nouveaux M-codes M70 à M72 seront disponnibles,
ils sauveront l'état avant l'appel du sous-programme, la restauration de l'état
au retour sera plus aisée.

=== Using the EMC Stat object to deal with status changes

Many actions depend on EMC status - is it in manual, MDI or auto mode?
is a program running, paused or idle? You cannot start an MDI command
while a G-code program is running, so this needs to be taken care of.
Many EMC actions take care of this themselves, and related buttons and
menu entries are deactivated when the operation is currently
impossible.

When using Python event handlers - which are at a lower level than
Actions - one needs to take care of dealing with status dependencies
oneself. For this purpose, there's the EMC Stat widget: to associate
EMC status changes with event handlers.

EMC Stat has no visible component - you just add it to your UI with
Glade. Once added, you can associate handlers with its following
signals:

* state-related:     emitted when E-Stop condition occurs, is reset, machine is turned on, or is turned off
  - +state-estop+
  - +state-estop-reset+
  - +state-on+,
  - +state-off+
* mode-related:    emitted when EMC enters that particular mode
  - +mode-manual+
  - +mode-mdi+
  - +mode-auto+
* interpreter-related:  emitted when the G-code interpreter changes into that mode
  - +interp-run+
  - +interp-idle+
  - +interp-paused+
  - +interp-reading+
  - +interp-waiting+


[[gladevcp:GladeVCP_Programming]]
== Programmation de GladeVCP

=== User Defined Actions

Most widget sets, and their associated user interface editors, support
the concept of callbacks - functions in user-written code which are
executed when 'something happens' in the UI - events like mouse clicks,
characters typed, mouse movement, timer events, window hiding and
exposure and so forth.

HAL output widgets typically map input-type events like a button press
to a value change of the associated HAL pin by means of such a -
predefined - callback. Within PyVCP, this is really the only type of event
handling supported - doing something more complex, like executing MDI
commands to call a G-code subroutine, is not supported.

Within GladeVCP, HAL pin changes are just one type of the general
class of events (called signals) in GTK+. Most widgets may originate such
signals, and the Glade editor supports associating such a signal with a
Python method or function name.

If you decide to use user-defined actions, your job is to write a
Python module whose class methods - or in the simple case, just
functions - can be referred to in Glade as event handlers. GladeVCP
provides a way to import your module(s) at startup and will
automatically link your event handlers with the widget signals as set
in the Glade UI description.

=== An example: adding custom user callbacks in Python

This is just a minimal example to convey the idea - details are laid
out in the rest of this section.

GladeVCP can not only manipulate or display HAL pins, you can also
write regular event handlers in Python. This could be used, among
others, to execute MDI commands. Here's how you do it:

Write a Python module like so and save as e.g. handlers.py:

[source,python]
----
nhits = 0
def on_button_press(gtkobj,data=None):
    global nhits nhits += 1 gtkobj.set_label("hits: %d" % nhits)
----

In Glade, define a button or HAL button, select the 'Signals' tab, and
in the GtkButton properties select the 'pressed' line. Enter
'on_button_press' there, and save the Glade file.

Then add the option '-u handlers.py' to the gladevcp command line. If
your event handlers are spread over several files, just add multiple
'-u <pyfilename>' options.

Now, pressing the button should change its label since it's set in the
callback function.

What the +-u+ flag does: all Python functions in this file are
collected and setup as potential callback handlers for your Gtk widgets
- they can be referenced from Glade 'Signals' tabs. The callback
handlers are called with the particular object instance as parameter,
like the GtkButton instance above, so you can apply any GtkButton
method from there.

Or do some more useful stuff, like calling an MDI command!

=== HAL value change events

HAL input widgets, like a LED, automatically associate their HAL pin state
(on/off) with the optical appearance of the widget (LED lit/dark).

Beyond this builtin functionality, one may associate a change
callback with any HAL pin, including those of predefined HAL
widgets. This fits nicely with the event-driven structure of a typical
widget application: every activity, be it mouse click, key, timer
expired, or the change of a HAL pin's value, generates a callback and
is handled by the same orthogonal mechanism.

For user-defined HAL pins not associated with a particular HAL widget,
the signal name is 'value-changed'. See the
<<gladevcp:Adding_HAL_pins,Adding HAL pins>> section below for
details.

HAL widgets come with a pre-defined signal called 'hal-pin-changed'. See the
<<gladevcp::hal-pin-changed_signal,Hal Widgets section>> for details. 


=== Programming model

The overall approach is as follows:

 - design your UI with Glade, and set signal handlers where you want
   actions associated with a widget
 - write a Python module which contains callable objects (see 'handler
   models' below)
 - pass your module's path name to gladevcp with the '-u <module>' option
 - gladevcp imports the module, inspects it for signal handlers and
   connects them to the widget tree
 - the main event loop is run.

==== The simple handler model

For simple tasks it's sufficient to define functions named after the
Glade signal handlers. These will be called when the corresponding
event happens in the widget tree. Here's a trivial example - it assumes
that the 'pressed' signal of a Gtk Button or HAL Button is linked to a
callback called 'on_button_press':

[source,python]
----------------------------------
nhits = 0
def on_button_press(gtkobj,data=None):
    global nhits
    nhits += 1
    gtkobj.set_label("hits: %d" % nhits)
----------------------------------

Add this function to a Python file and run as follows:

    gladevcp -u <myhandler>.py mygui.ui

Note communication between handlers has to go through global
variables, which does not scale well and is positively un-pythonic.
This is why we came up with the class-based handler model.

==== The class-based handler model

The idea here is: handlers are linked to class methods. The underlying
class(es) are instantiated and inspected during GladeVCP startup and
linked to the widget tree as signal handlers. So the task now is to
write:

 -  one or more several class definition(s) with one or several methods,
   in one module or split over several modules,
 -  a function 'get_handlers' in each module which will return a list of
   class instances to GladeVCP - their method names will be linked to
   signal handlers

Here is a minimum user-defined handler example module:

[source,python]
----------------------------------
class MyCallbacks :
    def on_this_signal(self,obj,data=None):
        print "this_signal happened, obj=",obj
    def get_handlers(halcomp,builder,useropts):
        return [MyCallbacks ()]
----------------------------------

Now, 'on_this_signal' will be available as signal handler to your
widget tree.

==== The get_handlers protocol

If during module inspection GladeVCP finds a function `get_handlers`,
it calls it as follows:

    get_handlers(halcomp,builder,useropts)

the arguments are:

 - halcomp - refers to the HAL component under construction
 - builder - widget tree - result of reading the UI definition (either
   referring to a GtkBuilder or libglade-type object)
 - useropts - a list of strings collected from the gladevcp 
   command line `-U <useropts>` option

GladeVCP then inspects the list of class instances and retrieves their
method names. Qualifying method names are connected to the widget tree
as signal handlers. Only method names which do not begin with an '_'
(underscore) are considered.

Note that regardless whether you're using the libglade or the new
GtkBuilder format for your Glade UI, widgets can always be referred to
as `builder.get_object(<nomwidget>)`. Also, the complete list of
widgets is available as `builder.get_objects()` regardless of UI
format.

=== Initialization sequence

It is important to know in which state of affairs your `get_handlers()`
function is called so you know what is safe to do there and what not.
First, modules are imported and initialized in command line order.
After successful import, `get_handlers()` is called in the following
state:

 -  the widget tree is created, but not yet realized (no toplevel
   `window.show()` has been executed yet)
 -  the halcomp HAL component is set up and all HAL widget's pins have
   already been added to it
 -  it is safe to add more HAL pins because `halcomp.ready()` has not yet
   been called at this point, so you may add your own pins, for instance
   in the class `__init__()` method.

Once all modules have been imported and method names extracted, the
following steps happen:

 -  all qualifying method names will be connected to the widget tree with
   `connect_signals()/signal_autoconnect()` (depending on the type of UI
   imported - GtkBuilder vs the old libglade format).
 - the HAL component is finalized with halcomp.ready()
 -  if a window ID was passed as argument, the widget tree is re-parented
   to run in this window, and Glade's toplevel window1 is abandoned (see
   FAQ)
 -  if a HAL command file was passed with `-H halfile`, it is executed
   with halcmd
 - the Gtk main loop is run.

So when your handler class is initialized, all widgets are existent
but not yet realized (displayed on screen). And the HAL component isn't
ready as well, so its unsafe to access pins values in your `__init__()`
method.

If you want to have a callback to execute at program start after it is
safe to access HAL pins, then a connect a handler to the realize signal
of the top level window1 (which might be its only real purpose). At
this point GladeVCP is done with all setup tasks, the halfile has been
run, and GladeVCP is about to enter the Gtk main loop.

=== Multiple callbacks with the same name

Within a class, method names must be unique. However, it is OK to have
multiple class instances passed to GladeVCP by get_handlers() with
identically named methods. When the corresponding signal occurs, these
methods will be called in definition order - module by module, and
within a module, in the order class instances are returned by
`get_handlers()`.

=== The GladeVCP `-U <useropts>` flag

Instead of extending GladeVCP for any conceivable option which could
potentially be useful for a handler class, you may use the -U
<useroption> flag (repeatedly if you wish). This flag collects a list
of <useroption> strings. This list is passed to the get_handlers()
function (useropts argument). Your code is free to interpret these
strings as you see fit. An possible usage would be to pass them to the
Python exec function in your `get_handlers()` as follows:

[source,python]
----------------------------------
debug = 0
...
def get_handlers(halcomp,builder,useropts):
    ...
    global debug # assuming there's a global var
    for cmd in useropts:
        exec cmd in globals()
----------------------------------

This way you can pass arbitrary Python statements to your module
through the gladevcp -U option, for example:

    gladevcp -U debug=42 -U "print 'debug=%d' % debug" ...

This should set debug to 2 and confirm that your module actually did it.

=== Persistent variables in GladeVCP

A annoying aspect of GladeVCP in its earlier form and pyvcp is the
fact that you may change values and HAL pins through text entry,
sliders, spin boxes, toggle buttons etc, but their settings are not
saved and restored at the next run of EMC - they start at the default
value as set in the panel or widget definition.

GladeVCP has an easy-to-use mechanism to save and restore the state of
HAL widgets, and program variables (in fact any instance attribute of
type int, float, bool or string).

This mechanism uses the popular '.ini' file format to save and reload
persistent attributes.

==== Persistence, program versions and the signature check

Imagine renaming, adding or deleting widgets in Glade:
an .ini file lying around from a previous program version, or an
entirely different user interface, would be not be able to restore the
state properly since variables and types might have changed.

GladeVCP detects this situation by a signature which depends on all
object names and types which are saved and to be restored. In the case
of signature mismatch, a new .ini file with default settings is
generated.

=== Using persistent variables

If you want any of Gtk widget state, HAL widgets output pin's values
and/or class attributes of your handler class to be retained across
invocations, proceed as follows:

 - import the +gladevcp.persistence+ module
 - decide which instance attributes, and their default values you want to
   have retained, if any
 - decide which widgets should have their state retained
 - describe these decisions in your handler class' +__init__()+ method
   through a nested dictionary as follows:

[source,python]
----------------------------------
def __init__(self, halcomp,builder,useropts):
    self.halcomp = halcomp
    self.builder = builder
    self.useropts = useropts
    self.defaults = {
        # the following names will be saved/restored as method attributes
        # the save/restore mechanism is strongly typed - the variables type will be derived from the type of the
        # initialization value. Currently supported types are: int, float, bool, string
        IniFile.vars : { 'nhits' : 0, 'a': 1.67, 'd': True ,'c' : "a string"},
        # to save/restore all widget's state which might remotely make sense, add this:
        IniFile.widgets : widget_defaults(builder.get_objects())
        # a sensible alternative might be to retain only all HAL output widgets' state:
        # IniFile.widgets: widget_defaults(select_widgets(self.builder.get_objects(), hal_only=True,output_only = True)),
    }
----------------------------------

Then associate an .ini file with this descriptor:

[source,python]
----------------------------------
self.ini_filename = __name__ + '.ini'
self.ini = IniFile(self.ini_filename,self.defaults,self.builder)
self.ini.restore_state(self)
----------------------------------

After `restore_state()`, self will have attributes set if as running the
following:

[source,python]
----------------------------------
self.nhits = 0
self.a = 1.67
self.d = True
self.c = "a string"
----------------------------------

Note that types are saved and preserved on restore. This example
assumes that the ini file didn't exist or had the default values from
self.defaults.

After this incantation, you can use the following IniFil methods:

ini.save_state(obj)::
	 saves objs's attributes as per IniFil.vars
	 dictionary and the widget state as described in IniFile.widgets in
	 self.defaults
ini.create_default_ini()::
	 create a .ini file with default values
ini.restore_state(obj)::
	restore HAL out pins and obj's attributes as
   	saved/initialized to default as above

To save the widget and/or variable state on exit, connect a signal
handler to the +window1+ (toplevel) destroy event:

[source,python]
----------------------------------
def on_destroy(self,obj,data=None):
    self.ini.save_state(self)
----------------------------------

Next time you start the GladeVCP application, the widgets should come
up in the state when the application was closed.

=== Hand-editing .ini files

You can do that, but note that the values in self.defaults override
your edits if there is a syntax or type error in your edit. The error
is detected, a console message will hint about that happened, and the
bad inifile will be renamed to have the .BAD suffix. Subsequent bad ini
files overwrite earlier .BAD files.

[[gladevcp:Adding_HAL_pins]]
=== Adding HAL pins

If you need HAL pins which are not associated with a specific HAL
widget, add them as follows:

[source,python]
----------------------------------
import hal_glib
...
# in your handler class __init__():
self.example_trigger = hal_glib.GPin(halcomp.newpin('example-trigger', hal.HAL_BIT, hal.HAL_IN))
----------------------------------

To get a callback when this pin's value changes, associate a
+value-change+ callback with this pin, add:

[source,python]
----------------------------------
self.example_trigger.connect('value-changed', self._on_example_trigger_change)
----------------------------------

and define a callback method (or function, in this case leave out the
+self+ parameter):

[source,python]
----------------------------------
# note '_' - this method will not be visible to the widget tree
def _on_example_trigger_change(self,pin,userdata=None):
    print "pin value changed to:" % (pin.get())
----------------------------------

=== Adding timers

Since GladeVCP uses Gtk widgets which rely on the
http://www.pygtk.org/pygtk2reference/gobject-functions.html[GObject]
base class, the full glib functionally is available. Here is an
example for a timer callback:

[source,python]
----------------------------------
def _on_timer_tick(self,userdata=None):
    ...
    return True # to restart the timer; return False for on-shot
...
# demonstrate a slow background timer - granularity is one second
# for a faster timer (granularity 1 ms), use this:
# glib.timeout_add(100, self._on_timer_tick,userdata) # 10Hz
glib.timeout_add_seconds(1, self._on_timer_tick)
----------------------------------

=== Examples, and rolling your own GladeVCP application

Visit +emc2/configs/gladevcp+ for running examples and starters for your own projects.


== FAQ

[qanda]
I get an unexpected unmap event in my handler function right after startup. What's this?::
   This is a consequence of your Glade UI file
   having the window1 Visible property set to True, together with
   re-parenting the GladeVCP window into Axis or touchy. The GladeVCP
   widget tree is created, including a top level window, and then
   'reparented into Axis', leaving that toplevel window laying around
   orphaned. To avoid having this useless empty window hanging around, it
   is unmapped (made invisible), which is the cause of the unmap signal
   you get. Suggested fix: set window1.visible to False, and ignore an
   initial unmap event.
My GladeVCP program starts, but no window appears where I expect it to be?::
   The window Axis allocates for GladeVCP will obtain the 'natural
   size' of all its child widgets combined. It's the child widget's job to
   request a size (width and/or height). However, not all widgets do
   request a width greater than 0, for instance the Graph widget in its
   current form. If there's such a widget in your Glade file and it's the
   one which defines the layout you might want to set its width
   explicitly. Note that setting the window1 width and height properties
   in Glade does not make sense because this window will be orphaned
   during re-parenting and hence its geometry will have no impact on
   layout (see above). The general rule is: if you manually run a UI file
   with 'gladevcp <uifile>' and its window has reasonable geometry, it
   should come up in Axis properly as well.

I want a blinking LED, so I ticked the checkbutton to let it blink with 100msec interval. 
It wont blink, and I get a startup warning: Warning: value "0" of type `gint' is 
invalid or out of range for property `led-blink-rate' of type `gint'?::
   This seems to be a glade bug. Just type over the blink rate field, and save again - this works for me.

My gladevcp panel in Axis doesnt save state when I close Axis,although I defined 
an on_destroy handler linked to the window destroy signal:: 
   Very likely this handler is linked to window1,
   which due to reparenting isnt usable for this purpose. Please link
   the on_destroy handler to the destroy signal of an interior
   window. For instance, I have a notebook inside window1, and linked
   on_destroy to the notebooks destroy signal, and that works fine. It
   doesnt work for window1.

// FIXME this is out of date
== Troubleshooting

 -  make sure your have the development version of EMC2 installed. You
   don't need the axisrc file any more, this was mentioned in the old
   GladeVcp wiki page.
 -  run GladeVCP or Axis from a terminal window. If you get Python errors,
   check whether there's still a +/usr/lib/python2.6/dist-packages/hal.so+
   file lying around besides the newer
   +/usr/lib/python2.6/dist-packages/_hal.so+ (note underscore); if yes,
   remove the +hal.so+ file. It has been superseded by hal.py in the same
   directory and  confuses the import mechanism.
 -  if you're using run-in-place, do a 'make clean' to remove any
   accidentally left over hal.so file, then 'make'.
 -  if you're using 'HAL_table' or 'HAL_HBox' widgets, be aware they have
   an HAL pin associated with it which is off by default. This pin
   controls whether these container's children are active or not.

== Implementation note: Key handling in Axis

We believe key handling works OK, but since it is new code, we're
telling about it you so you can watch out for problems; please let us
know of errors or odd behavior. This is the story:

Axis uses the TkInter widget set. GladeVCP applications use Gtk
widgets and run in a separate process context. They are hooked into
Axis with the Xembed protocol. This allows a child application like
GladeVCP to properly fit in a parent's window, and - in theory - have
integrated event handling.

However, this assumes that both parent and child application properly
support the Xembed protocol, which Gtk does, but TkInter doesn't. A
consequence of this is that certain keys would not be forwarded from a
GladeVCP panel to Axis properly under all circumstances. One of these
situations was the case when an Entry, or SpinButton widget had focus:
in this case, for instance an Escape key would not have been forwarded
to Axis and cause an abort as it should, with potentially disastrous
consequences.

Therefore, key events in GladeVCP are explicitly handled, and
selectively forwarded to Axis, to assure that such situations cannot
arise. For details, see the `keyboard_forward()` function in
`lib/python/gladevcp/xembed.py`.
