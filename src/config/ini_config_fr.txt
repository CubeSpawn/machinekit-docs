:lang: fr
:toc:

= Démarrage de LinuxCNC

== Script de lancement

LinuxCNC est lancé avec le fichier de script linuxcnc.

    utilisation: linuxcnc [options] [<fichier ini>]

    options:
        -v = verbose - informations de fonctionnement
        -d = commande d'écho à l'écran pour le débogage

Le fichier de script _linuxcnc_ lit le fichier ini et lance LinuxCNC. La section
[HAL] du fichier .ini spécifie l'ordre de chargement des fichiers de HAL, si
plusieurs sont utilisés. Après que les fichiers HAL soient chargés, l'interface
graphique est chargée à son tour puis le fichier HAL POSTGUI. Si des objets
pyvcp ont été créés avec des pins de HAL, le fichier _postgui.hal_ doit
effectuer les raccordements à ces pins.

Si aucun fichier ini n'est passé en argument au script _linuxcnc_ le sélecteur
de configuration est lancé pour permettre à l'utilisateur de choisir parmi les
exemples de configuration.

== Fichiers utilisés pour la configuration

LinuxCNC est entièrement configuré avec des fichiers textes classiques.
Tous ces fichiers peuvent être lus et modifiés dans n'importe quel
éditeur de texte disponible dans toute distribution Linux.footnote:[Ne
pas confondre un éditeur de texte et un traitement de texte. Un
éditeur de texte comme gedit ou kwrite produisent des fichiers
uniquement en texte. Les lignes de textes sont séparées les unes des
autres. Un traitement de texte comme Open Office produit des fichiers
avec des paragraphes, des mises en formes des mots. Ils ajoutent des
codes de contrôles, des polices de formes et de tailles variées etc. Un
éditeur de texte n'a rien de tout cela.]
Soyez prudent lorsque vous modifierez ces fichiers, certaines
erreurs pourraient empêcher le démarrage de LinuxCNC. Ces fichiers sont lus à
chaque fois que le logiciel démarre. Certains d'entre eux sont lus de
nombreuses fois pendant l'exécution de LinuxCNC.

Les fichiers de configuration inclus:

INI::
     (((INI))) Le fichier ini écrase les valeurs par défaut compilées dans
    le code de LinuxCNC. Il contient également des sections qui sont lues
    directement par HAL (Hardware Abstraction Layer, couche
    d'abstraction matérielle).

HAL::
     (((HAL))) Les fichiers hal installent les modules de process, ils
    créent les liens entre les signaux de LinuxCNC et les broches spécifiques du
    matériel.

VAR::
     (((VAR))) Ce fichier contient une suite de numéros de variables. Ces
    variables contiennent les paramètres qui seront utilisés par
    l'interpréteur. Ces valeurs sont enregistrées et réutilisées d'une
    exécution à l'autre. 

TBL::
    (((TBL))) Ce fichier contient les informations relatives aux outils.
    Voir la section 'Fichier d'outils' du Manuel de l'utilisateur pour plus
    d'infos.

NML::
     (((NML))) Ce fichier configure les voies de communication utilisées
    par LinuxCNC. Il est normalement réglé pour lancer toutes les communications
    avec un seul ordinateur, peut être modifié pour communiquer entre
    plusieurs ordinateurs.

 .linuxcncrc::
     (((.linuxcncrc))) Ce fichier enregistre des informations spécifiques à
    l'utilisateur, il a été créé pour enregistrer le nom du répertoire
    lorsque l'utilisateur choisit sa première configuration
    de LinuxCNC.footnote:[Habituellement, ce fichier est dans le répertoire home
    de l'utilisateur (ex: _/home/user/_ )]

Les éléments avec le repère _(hal)_ sont utilisés seulement pour les
fichiers de HAL en exemples. C'est
une bonne convention. D'autres éléments sont utilisés directement par
LinuxCNC et doivent toujours avoir la section et le nom donné à l'item.


== Double passe (TWOPASS) 

LinuxCNC 2.5 supporte le processus dit TWOPASS des fichiers de configuration hal,
ce qui aide à la modularité des fichiers hal et améliore leur lisibilité.
(les fichiers Hal sont spécifiés dans le fichier ini de LinuxCNC, dans
l'instance HAL sous la forme *+[HAL]HALFILE=nomfichier)+*.

Normalement, un jeu de un ou plusieurs fichiers de configuration HAL doivent
utiliser une seule et unique ligne loadrt pour charger le module du kernel qui
pourra gérer de multiples instances d'un même composant.  Par exemple: si vous
utilisez une portes AND à deux entrées, composant (and2), à trois endroits
différents de votre configuration, vous ne devez avoir que cette seule ligne
quelque part pour le spécifier:
----
loadrt and2 count=3
----

Ce qui fournira finalement les composants and2.0, and2.1, and2.2.

Les configurations seront plus lisibles si vous spécifiez les composants sous
la forme names=option quand c'est supporté, par exemple:
----
loadrt and2 names=aa,ab,ac
----

Ce qui nommera les composants aa, ab, ac.

Il pourrait apparaitre un problème de maintenance pour garder la trace des
composants et de leur noms après avoir ajouté (ou enlevé) un composant,
vous devrez trouver et mettre à jour, la ligne de directives de loadrt,
applicable à ce composant.

Le processus TWOPASS est activé par inclusion d'un paramètre dans le fichier ini:
----
[HAL]TWOPASS=anything
----

Avec ce réglage, vous pouvez avoir de multiples spécifications comme:
----
loadrt and2 names=aa
 ...
loadrt and2 names=ab,ac
 ...
loadrt and2 names=ad
----

Ces commandes peuvent être placées dans différents fichiers HALFILES. Les
HALFILES sont traités dans leur ordre d'apparition dans le fichier ini.

Avec le processus double passe, tous les [HAL]HALFILES sont lus une première
fois et les multiples apparitions de la directive loadrt sont cumulées pour
chaque module. Aucune commande hal n'est exécutée lors de cette passe initiale.

Après la passe initiale, les modules sont automatiquement chargés 
en nombre égal au nombre total lors de l'utilisation de count=option ou
de tous les noms spécifiés individuellement lors de l'utilisation de
names=option.

Une seconde passe est alors faite pour exécuter toutes les autres instructions
de hal spécifiées dans les HALFILES.  Les commandes addf qui associent les
fonctions de composants avec l'exécution du thread sont exécutées selon leur
ordre d'apparition avec les autres commandes dans cette seconde passe.

Bien que vous puissiez utiliser indifféremment les options avec count= ou names=,
elles sont toutefois exclusives. Un seul type peut être utilisé pour un même
module.

Le processus TWOPASS n'est pas effectif lors de l'usage de names=option.
Cette option permet d'avoir un nom unique qui soit mnémonique ou plus pertinent
avec la configuration. Par exemple: si vous utilisez un composant _dérivé_ pour
estimer la vitesse et l'accélération de chacun des coordonnées (x,y,z), utiliser
la méthode count= donnera un composant au nom ésotérique comme ddt.0, ddt.1,
ddt.2, etc.

Alternativement, l'utilisation de names=option comme:
----
loadrt ddt names=xvit,yvit,zvit
 ...
loadrt ddt names=xaccel,yaccel,zaccel
----

donnera des composants plus parlants, nommés xvit,yvit,zvit, xaccel,yaccel,
zaccel.

Beaucoup de composants fournis avec la distribution ont été créés avec
_comp utility_ et supportent la méthode names=option. Il s'agit notamment de
composants logiques qui sont les briques de beaucoup de configurations HAL.

Exemples d'inclusions:
----
and2,ddt,deadzone,flipflop,or2,or4,mux2,mux4,scale,sum2,timedelay,lowpass
----

et beaucoup d'autres.

Les composants utilisateur créés avec _comp utility_ supportent également
automatiquement la méthode names=option.  En plus des composants générés
avec _comp utility_, quelques autres composants comme _encoder_ et
_pid_ supportent aussi names=option.

== Organisation du fichier ini

Organisation du fichier ini:: (((Fichier ini)))
Un fichier ini typique suit une organisation simple;

* commentaires.
* sections.
* variables.

Chacun de ces éléments est séparé, sur une seule ligne. Chaque fin de
ligne ou retour chariot crée un nouvel élément.

=== Commentaires (((commentaires)))

Une ligne de commentaires débute avec un *;* ou un *#*. Si le logiciel qui
analyse le fichier ini rencontre l'un ou l'autre de ces caractères, le
reste de la ligne est ignoré. Les commentaires peuvent être utilisés
pour décrire ce que font les éléments du fichier ini.
----
; Ceci est le fichier de configuration de ma petite fraiseuse.
----
Des commentaires peuvent également être utilisés pour choisir entre
plusieurs valeurs d'une seule variable.
----
DISPLAY = axis
# DISPLAY = touchy
----

Dans cette liste, la variable DISPLAY est positionnée sur
axis puisque toutes les autres sont commentées. Si quelqu'un édite une
liste comme celle-ci et, par erreur, dé-commente deux lignes, c'est la
première rencontrée qui sera utilisée.

Notez que dans une ligne de variables, les caractères *#* et *;*
n'indiquent pas un commentaire.
----
INCORRECT = valeur     # et un commentaire

# Commentaire correct
CORRECT = valeur
----

=== Sections (((Sections)))
Les différentes parties d'un fichier .ini sont regroupées en sections.
Une section commence par son nom en majuscules entre crochets [UNE_SECTION].
L'ordre des sections est sans importance. 

Les sections suivantes sont utilisées par LinuxCNC:

* [<<sub:Section-EMC,EMC>>] informations générales.
* [<<sub:Section-DISPLAY,DISPLAY>>] sélection du type d'interface graphique.
* [<<sub:Section-FILTER,FILTER>>] sélection d'un programme de filtrage.
* [<<sub:Section-RS274NGC,RS274NGC>>] ajustements utilisés par l'interpréteur
de g-code.
* [<<sub:Section-LINUXCNCMOT,LINUXCNCMOT>>] réglages utilisés par le contrôleur
de mouvements temps réel.
* [<<sub:Section-TASK,TASK>>] réglages utilisés par le contrôleur de tâche.
* [<<sub:Section-HAL,HAL>>] spécifications des fichiers .hal.
* [<<sub:Section-HALUI,HALUI>>] commandes MDI utilisées par HALUI.
* [<<sub:Section-TRAJ,TRAJ>>] réglages additionnels utilisés par le contrôleur
de mouvements temps réel.
* [<<sub:Section-AXIS,AXIS_0 à AXIS_n>>] groupes de variables relatives
aux axes.
* [<<sub:Section-LINUXCNCIO,LINUXCNCIO>>] réglages utilisés par le contrôleur
d'entrées/sorties.

=== Variables (((Variables)))
Une ligne de variables est composée d'un nom de variable, du signe
égal (=) et d'une valeur. Tout, du premier caractère non blanc qui suit
le signe = jusqu'à la fin de la ligne, est passé comme valeur à la
variable. Vous pouvez donc intercaler des espaces entre les symboles si
besoin. Un nom de variable est souvent appelé un mot clé.

Les paragraphes suivants détaillent chaque section du fichier de
configuration, en utilisant des exemples de variables dans les lignes
de configuration.

Certaines de ces variables sont utilisées par LinuxCNC. Elles doivent
toujours utiliser le nom de section et le nom de variable dans leur
appellation. D'autres variables ne sont utilisées que par HAL. Les noms
des sections et les noms des variables indiquées, sont ceux qui sont
utilisés dans les exemples de fichiers de configuration.

Les variables personnalisées peuvent être utilisées dans vos fichiers
HAL avec la syntaxe suivante:
----
[SECTION]VARIABLE
----

=== Définitions (((Définitions)))
Machine Unit #(unité machine)::
L'unité de mesure pour un axe est déterminée par les paramètres de
la section _[TRAJ]_. Une unité machine est égale à une unité telle
que spécifiée par _LINEAR_UNITS_ ou _ANGULAR_UNITS_.

[[sec:Details-fichier-INI]]
== Détails des sections du fichier ini


[[sub:Section-EMC]]
=== Section EMC(((Section [EMC] du fichier ini)))


VERSION = $Revision: 1.5 $::
     Le numéro de version du fichier INI. La valeur indiquée ici semble
    étrange, car elle est automatiquement mise à jour lors de l'utilisation
    du système de contrôle de révision. C'est une bonne idée de changer ce
    numéro à chaque fois que vous modifiez votre fichier. Si vous voulez le
    modifier manuellement, il suffit de changer le numéro sans toucher au
    reste.

MACHINE = ma machine::
     C'est le nom du contrôleur, qui est imprimé dans le haut de la
    plupart des fenêtres. Vous pouvez insérer ce que vous voulez ici tant
    que ça reste sur une seule ligne.

DEBUG = 0::
     Niveau de débogage 0 signifie qu'aucun message ne sera affiché dans le
    terminal pendant le fonctionnement de LinuxCNC. Les drapeaux de débogage
    ne sont généralement utiles pour les développeurs. Voi
    ../src/linuxcnc/nml_intf/linuxcncglb.h pour les autres paramètres.

[[sub:Section-DISPLAY]]
=== Section DISPLAY

(((Section [DISPLAY] du fichier ini)))

Les différentes interfaces graphiques utilisent différentes options
qui ne sont pas supportées par toutes les interfaces utilisateur.
Les deux principales interfaces pour LinuxCNC sont _AXIS_ et _Touchy_.
Axis est une interface pour une utilisation avec un ordinateur classique et
son moniteur, Touchy est à utiliser avec les ordinateurs à écran tactile.
Pour plus d'informations, voire la section Interfaces du Manuel de l'utilisateur.

DISPLAY = axis:: 
    Le nom de l'interface graphique à utiliser. Les options disponibles
    sont les suivantes: _axis_,(((axis))) _touchy_,(((touchy))) _keystick_,
    (((keystick))) _mini_,(((mini))) _tklinuxcnc_,(((tklinuxcnc))) _xlinuxcnc_,
    (((xlinuxcnc)))

POSITION_OFFSET = RELATIVE::
     Le système de coordonnées (RELATIVE ou MACHINE) à utiliser au
    démarrage de l'interface utilisateur. Le système de coordonnées
    RELATIVE reflète le G92 et le décalage d'origine G5x actuellement
    actifs.

POSITION_FEEDBACK = ACTUAL::
     Valeur de la position (COMMANDED ou ACTUAL) à afficher au démarrage de
    l'interface utilisateur. La position COMMANDED est la position exacte
    requise par LinuxCNC. La position ACTUAL est la position retournée par
    l'électronique des moteurs.

MAX_FEED_OVERRIDE = 1.2::
     La correction de vitesse maximum que l'opérateur peut utiliser. 1.2
    signifie 120% de la vitesse programmée.

MIN_SPINDLE_OVERRIDE = 0.5::
     Correction de vitesse minimum de broche que l'opérateur pourra
    utiliser. 0.5 signifie 50% de la vitesse de broche programmée. (utile
    si il est dangereux de démarrer un programme avec une vitesse de broche
    trop basse).

MAX_SPINDLE_OVERRIDE = 1.0::
     Correction de vitesse maximum de broche que l'opérateur pourra
    utiliser. 1.0 signifie 100% de la vitesse de broche programmée.

PROGRAM_PREFIX = ~/linuxcnc/nc_files::
     Répertoire par défaut des fichiers de g-codes et emplacement des
    M-codes définis par l'utilisateur.

INTRO_GRAPHIC = linuxcnc.gif::
    L'image affichée sur l'écran d'accueil.

INTRO_TIME = 5::
    Durée d'affichage de l'écran d'accueil.

CYCLE_TIME = 0.05::
    Cycle time in seconds that display will sleep between polls.

Les éléments suivants sont utilisés uniquement si vous sélectionnez AXIS
comme programme d'interface utilisateur.

DEFAULT_LINEAR_VELOCITY = .25::
     Vitesse minimum par défaut pour les jogs linéaires, en unités machine
    par seconde. Seulement utilisé dans l'interface AXIS.

MIN_VELOCITY = .01::
    Valeur approximative minimale du curseur de vitesse de jog. 

MAX_LINEAR_VELOCITY = 1.0::
     Vitesse maximum par défaut pour les jogs linéaires, en unités machine
    par seconde. Seulement utilisé dans l'interface AXIS.

MIN_LINEAR_VELOCITY = .01::
    Approximativement la valeur minimale du curseur de vitesse de jog.

DEFAULT_ANGULAR_VELOCITY = .25::
     Vitesse minimum par défaut pour les jogs angulaires, en unités machine
    par seconde. Seulement utilisé dans l'interface AXIS.

MIN_ANGULAR_VELOCITY = .01::
    Valeur approximative minimale du curseur de vitesse angulaire de jog.

MAX_ANGULAR_VELOCITY = 1.0::
     Vitesse maximum par défaut pour les jogs angulaires, en unités machine
    par seconde. Seulement utilisé dans l'interface AXIS.

INCREMENTS = 1 mm, .5 mm, ...::
    Définit les incréments disponibles pour le jog incrémental.
    Les incréments peuvent être utilisés pour remplacer la valeur par défaut.
    Ces valeurs doivent contenir des nombres décimaux (ex. 0.1000) ou des
    nombres fractionnaires (ex. 1/16), éventuellement suivis par une unité
    parmi _cm_, _mm_, _um_, _inch_, _in_ ou _mil_. Si aucune unité n'est
    spécifiée, les unités natives de la machine seront utilisées.

Distances métriques et impériales peuvent être mélangées::
    INCREMENTS = 1 inch, 1 mil, 1 cm, 1 mm, 1 um sont des entrées valides.

OPEN_FILE = /full/path/to/file.ngc::
    Le fichier NC à utiliser au démarrage d'AXIS. Utilisez une chaîne
    vide "" et aucun fichier sera chargé au démarrage.

EDITOR = gedit::
     L'éditeur à utiliser lors du choix _Éditer fichier_ du menu d'AXIS, pour
éditer le G-code.
    Ceci doit être configuré pour que cet item de menu s'active.
    Une autre possibilité valide est: gnome-terminal -e vim.

PYVCP = /filename.xml::
     Le fichier de description du panneau PyVCP. Voir la section PyVCP.

LATHE = 1::
     Passe l'affichage en mode tour, avec vue de dessus et la visu soit en
    rayon, soit en diamètre.

GEOMETRY = XYZABCUVW::
     Contrôle de prévisualisation du parcours d'outil d'un mouvement rotatif.
    Cet item consiste en une suite de lettre d'axe, optionnellement précédé
    d'un signe *-*. Seuls, les axes définis par *[TRAJ]AXES* peuvent être
    utilisés. Cette séquence spécifie l'ordre dans lequel l'effet de chaque
    axe est appliqué. Un signe *-* inverse le sens de la rotation.
     La chaine GEOMETRY correcte dépend de la configuration de la machine et
    de la cinématique utilisée pour la contrôler. La chaine exemple GEOMETRY=XYZBCUVW
    est pour une machine à 5 axes pour laquelle la cinématique déplace UVW
    en coordonnées système de l'outil et XYZ déplace la pièce en coordonnées
    système. L'ordre des lettres est important, parce qu'il donne expressément
    l'ordre dans lequel les différentes transformations seront appliquées.
    Par exemple: tourner autour de C puis de B est différent de tourner
    autour de B puis de C. La géométrie n'a pas d'effet sans rotation d'axes.

ARCDIVISION = 64::
     Ajuste la valeur de prévisualisation des arcs. Les arcs sont visualisés
    en les divisant par un nombre de lignes droites; un semi-cercle est divisé
    en _ARCDIVISION_ de tronçons. Les valeurs élevées donnent une meilleure
    précision à la pré-visualisation, mais sont plus lentes et donne un écran
    plus saccadé. Les petites valeurs sont moins précises mais plus rapides,
    l'affichage résultant est plus rapide. La valeur par défaut de 64
    signifie qu'un cercle de 3 pouces maximum sera affiché dans moins de 3
    centièmes de mm, (.03%).footnote:[ Dans LinuxCNC 2.4 et précédents,
    la valeur par défaut était de 128.]

MDI_HISTORY_FILE =::
     Le nom du fichier d'historique des commandes MDI. Si rien n'est spécifié,
    Axis enregistrera cet historique dans _.axis_mdi_history_ dans le
    répertoire home de l'utilisateur. C'est très pratique dans le cas de
    multiples configurations sur la même machine.

HELP_FILE = tklinucnc.txt::
    Chemin du fichier d'aide (non utilisé avec AXIS).

[[sub:Section-FILTER]]
=== Section FILTER

(((Section [FILTER] du fichier ini))) 

AXIS a la possibilité d'envoyer les fichiers chargés au travers d'un programme de
filtrage. Ce filtrage peut réaliser toutes sortes de tâches. Parfois aussi simple
que s'assurer que le programme se termine bien par M2, ou parfois aussi compliqué
que détecter si le fichier d'entrée est une image et en générer le G-code pour
graver la forme qu'il à ainsi défini.
La section _[FILTER]_ du fichier ini, contrôle comment les filtres fonctionnent.
Premièrement, pour chaque type de fichier, écrire une ligne _PROGRAM_EXTENSION_.
Puis, spécifier le programme à exécuter pour chaque type de filtre. Ce
programme reçoit le nom du fichier d'entrée dans son premier argument, il
doit écrire le code RS274/NGC sur la sortie standard. C'est cette sortie qui
sera affichée dans la zone de texte, pré-visualisée dans la zone du parcours
d'outil et enfin, exécutée par LinuxCNC quand il sera mis en marche.
----
PROGRAM_EXTENSION = .extension Description
----

Si votre fichier de sortie est tout en majuscules, vous devez ajouter
la ligne suivante:
----
PROGRAM_EXTENSION = .NGC XYZ Post Processor
----

Les lignes suivantes ajoutent le support pour le convertisseur _image-to-gcode_
fourni avec LinuxCNC:
----
PROGRAM_EXTENSION = .png,.gif,.jpg Greyscale Depth Image
    png = image-to-gcode
    gif = image-to-gcode
    jpg = image-to-gcode
----

Il est également possible de spécifier un interpréteur:
----
PROGRAM_EXTENSION = .py Python Script
    py = python
----

De cette façon, n'importe quel script Python pourra être ouvert et ses sorties
seront traitées comme du g-code. Un exemple de script de ce genre est disponible:
nc_files/holecircle.py.
Ce script crée le G-code pour percer une série de trous séquents à la
périphérie d'un cercle.
De nombreux générateur de G-code sont par ailleurs disponibles sur le wiki:
http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Simple_LinuxCNC_G-Code_Generators[à la
page des générateurs de G-code].

Si la variable d'environnement AXIS_PROGRESS_BAR est activée, alors les lignes
écrites sur stderr de la forme
----
FILTER_PROGRESS=%d
----

activeront la barre de progression d'AXIS qui donnera le pourcentage. Cette
fonctionnalité devrait être utilisée par tous les filtres susceptibles de
fonctionner pendant un long moment.

[[sub:Section-RS274NGC]]
=== Section RS274NGC

(((Section [RS274NGC] du fichier ini)))

PARAMETER_FILE = monfichier.var::
    (((PARAMETER FILE))) Le fichier situé dans le même répertoire que le
    fichier ini qui contiendra les paramètres utilisés par l'interpréteur
    (enregistré entre chaque lancement). 

RS274NGC_STARTUP_CODE = G01 G17 G20 G40 G49 G64.1 P0.001 G80 G90 G92 G94 G97 G98::
    (((RS274NGC STARTUP CODE))) Une chaine de codes NGC qui sera utilisée
    pour initialiser l'interpréteur. Elle ne se substitue pas à la
    spécification des G-codes modaux du début de chaque fichier ngc. Les
    codes modaux des machines diffèrent, ils pourraient être modifiés par
    les G-codes interprétés plutôt dans la session. 

SUBROUTINE_PATH = ncsubroutines:/tmp/testsubs:lathesubs:millsubs::
    (((SUBROUTINE PATH))) Spécifie une liste, séparée par (:) d'au maximum 10
    répertoires dans lesquels seront cherchés les fichier de sous-programme
    spécifiés dans le g-code. Ces répertoires sont inspectés après que ne le
    soit [DISPLAY]PROGRAM_PREFIX (si il est spécifié) et avant que ne le soit
    [WIZARD]WIZARD_ROOT (si il est spécifié). La première occurrence avec le
    sous-programme recherché est utilisée. Les répertoires sont spécifiés
    relativement au répertoire courant du fichier ini ou par des chemins
    absolus. La liste ne doit contenir aucun espace blanc.

USER_M_PATH = myfuncs:/tmp/mcodes:experimentalmcodes::
    (((USER M PATH))) Spécifie une liste de répertoires, séparés par (:) (sans
    aucun espace blanc) pour les fonctions définies par l'utilisateur.
    Le nombre maximum de répertoires est défini au moment de la compilation
    par: *+USER_DEFINED_FUNCTION_MAX_DIRS=5+*.
    Les répertoires sont spécifiés relativement au répertoire courant du
    fichier ini ou par des chemins absolus. La liste ne doit contenir aucun
    espace blanc.

Une recherche est faite pour chaque fonction utilisateur définie possible,
    typiquement _M100_ à _M199_.
    L'ordre de recherche est le suivant:

 . [DISPLAY]PROGRAM_PREFIX (si il est spécifié)
 . Si [DISPLAY]PROGRAM_PREFIX n'est pas spécifié, cherche dans le répertoire
    par défaut: nc_files
 . Recherche ensuite dans chaque répertoire de la liste [RS274NGC]USER_M_PATH

Le premier M1xx trouvé au cours de la recherche est utilisé pour chaque M1xx.

[[sub:Section-LINUXCNCMOT]]
=== Section LINUXCNCMOT

(((Section [LINUXCNCMOT] du fichier ini)))

Vous pouvez trouver d'autres entrées dans cette section, elles ne doivent pas
être changées.

BASE_PERIOD = 50000::
    (((BASE PERIOD))) (HAL) Période de base des tâches, exprimée en ns.
    C'est la plus rapide des horloges de la machine.
     Avec un système à servomoteurs, il n'y a généralement pas de raison
    pour que _BASE_PERIOD_ soit plus petite que _SERVO_PERIOD_.
    Sur une machine de type _step&direction_ avec génération logicielle
    des impulsions de pas, c'est _BASE_PERIOD_  qui détermine le nombre
    maximum de pas par seconde. Si de longues
    impulsions de pas ou de longs espaces entre les impulsions ne sont pas
    requis par l'électronique, la fréquence maximum absolue est de un pas
    par _BASE_PERIOD_. Ainsi, la _BASE_PERIOD_  utilisée ici donnera une
    fréquence de pas maximum absolue de 20000
    pas par seconde. 50000ns est une valeur assez large. La plus petite
    valeur utilisable est liée au résultat <<cha:test-de-latence, du test de latence>>,
    à la longueur des impulsions de pas nécessaire et à la vitesse du µP.
    Choisir une BASE_PERIOD trop basse peut amener à des messages
    _Unexpected realtime delay_, des blocages ou des reboots spontanés.

SERVO_PERIOD = 1000000::
    (((SERVO PERIOD))) (hal) Période de la tâche _Servo_, exprimée également en nanosecondes. 
    Cette valeur sera arrondie à un multiple entier de _BASE_PERIOD_.
    Elle est utilisée aussi sur des systèmes basés sur des moteurs pas à pas.
    C'est la vitesse avec laquelle la nouvelle position des moteurs est
    traitée, les erreurs de suivi vérifiées, les valeurs des sorties PID
    sont rafraichies etc.
    Sur la plupart des systèmes cette valeur n'est pas à modifier. Il
    s'agit du taux de mise à jour du planificateur de mouvement de bas niveau.

TRAJ_PERIOD = 1000000::
    (((TRAJ PERIOD))) (hal) Période du planificateur de trajectoire, exprimée en nanosecondes. 
    Cette valeur sera arrondie à un multiple entier de _SERVO_PERIOD_.
    Excepté pour les machines avec une cinématique particulière
    (ex: hexapodes) Il n'y a aucune raison de rendre cette valeur
    supérieure à _SERVO_PERIOD_.

[[sub:Section-TASK]]
=== Section TASK

(((Section [TASK] du fichier ini)))

TASK = milltask::
     Indique le nom de la _tâche_ exécutable. La tâche réalise différentes
    actions, telles que communiquer avec les interfaces utilisateur au dessus
    de NML, communiquer avec le planificateur de mouvements temps réel dans
    la mémoire partagée non-HAL, et interpréter le g-code.
    Actuellement il n'y a qu'une seule tâche exécutable qui fait sens pour
    99,9% des utilisateurs, milltask.

CYCLE_TIME = 0.010::
     Période exprimée en secondes, à laquelle LINUXCNCTASK va tourner. Ce
    paramètre affecte l'intervalle de polling lors de l'attente de la fin
    d'un mouvement, lors de l'exécution d'une pause d'instruction et quand
    une commande provenant d'une interface utilisateur est acceptée. Il
    n'est généralement pas nécessaire de modifier cette valeur.

[[sub:Section-HAL]]
=== Section HAL

(((Section [HAL] du fichier ini )))

TWOPASS=ON::
    Utilise le processus _twopass_ (double passe) pour charger les composants
    HAL. Avec le processus TWOPASS, tous les fichiers [HAL]HALFILES sont
    premièrement lus et les occurrences multiples des directives à loadrt
    pour chaque module sont cumulées. Aucune commande HAL n'est exécutée à
    la première passe.

HALFILE = example.hal::
     Exécute le fichier _example.hal_ au démarrage. Si _HALFILE_  est
    spécifié plusieurs fois, les fichiers sont exécutés dans l'ordre
    de leur apparition dans le fichier ini. Presque toutes les
    configurations auront au moins un _HALFILE_ . Les systèmes à moteurs
    pas à pas ont généralement deux de ces
    fichiers, un qui spécifie la configuration générale des moteurs
    _core_stepper.hal_ et un qui spécifie le brochage des sorties
    _xxx_pinout.hal_.

HAL = command::
    Exécute _command_ comme étant une simple commande hal. Si _HAL_ est
    spécifié plusieurs fois, les commandes sont exécutées dans
    l'ordre où elles apparaissent dans le fichier ini. Les lignes _HAL_
    sont exécutées après toutes les lignes _HALFILE_.

SHUTDOWN = shutdown.hal::
    Exécute le fichier _shutdown.hal_ quand LinuxCNC s'arrête. Selon les
    pilotes de matériel utilisés, il est ainsi possible de positionner les
    sorties sur des valeurs définies quand LinuxCNC s'arrête normalement.
    Cependant, parce qu'il n'y a aucune garantie que ce fichier sera
    exécuté (par exemple, dans le cas d'une panne de l'ordinateur), il ne
    remplace pas une véritable chaîne physique d'arrêt d'urgence ou
    d'autres logiciels de protection des défauts de fonctionnement.

POSTGUI_HALFILE = example2.hal::
    (Seulement avec les interfaces TOUCHY et AXIS) Exécute _example2.hal_
    après que l'interface graphique ait créé ses HAL pins.

[[sub:Section-HALUI]]
=== Section HALUI

(((Section [HALUI] du fichier ini )))

MDI_COMMAND = G53 G0 X0 Y0 Z0::
     Une commande MDI peut être exécuté en utilisant _halui.mdi-command-00_.
    Incrémente le nombre pour chaque commande énumérée dans la section [HALUI].

[[sub:Section-TRAJ]]
=== Section TRAJ
(((Section [TRAJ] du fichier ini )))

La section [TRAJ] contient les paramètres généraux du module
planificateur de trajectoires de LINUXCNCMOT. Vous n'aurez pas à modifier
ces valeurs si vous utilisez LinuxCNC avec une machine à trois axes en
provenance des USA. Si vous êtes dans une zone métrique, utilisant des
éléments matériels métriques, vous pourrez utiliser le fichier
_stepper_mm.ini_ dans lequel les valeurs sont déjà configurées dans cette
unité.

COORDINATES = X Y Z::
      Les noms des axes à contrôler. X, Y, Z, A, B, C, U, V, et W sont
    valides. Seuls les axes nommés dans _COORDINATES_ seront acceptés dans
    le G-code. Cela n'a aucun effet sur l'ordonnancement des noms d'axes depuis
    le G-code (X- Y- Z-) jusqu'aux numéros d'articulations. Pour une _cinématique 
    triviale_, X est toujours l'articulation 0, A est toujours l'articulation 4, 
    U est toujours l'articulation 7 et ainsi de suite. Il est permis d'écrire les
    noms d'axe par paire (ex: X Y Y Z pour une machine à portique) mais
    cela n'a aucun effet.

AXES = 3::
      Une unité de plus que le plus grand numéro d'articulation du système.
    Pour une machine XYZ, les articulations sont numérotées 0, 1 et 2. Dans
    ce cas, les AXES sont 3. Pour un système XYUV utilisant une
    _cinématique triviale_, l'articulation V est numérotée 7 et donc les
    AXES devraient être 8. Pour une machine à cinématique non triviale (ex:
    scarakins) ce sera généralement le nombre d'articulations contrôlées.

HOME = 0 0 0::
      Coordonnées de l'origine machine de chaque axe. De nouveau, pour une
    machine 4 axes, vous devrez avoir 0 0 0 0. Cette valeur est utilisée
    uniquement pour les machines à cinématique non triviale. Sur les
    machines avec cinématique triviale, cette valeur est ignorée.

LINEAR_UNITS=<units>::
      (((LINEAR UNITS)))Le nom des unités utilisées dans le fichier INI.
     Les choix possibles sont _in_, _inch_, _imperial_, _metric_, _mm_.  
    Cela n'affecte pas les unités linéaires du code NC (pour cela il y a
    les mots G20 et G21). 

ANGULAR_UNITS=<units>::
     (((ANGULAR UNITS)))Le nom des unités utilisées dans le fichier INI.
    Les choix possibles sont _deg_, _degree_ (360 pour un cercle), _rad_,
    _radian_ (2pi pour un cercle), _grad_, ou _gon_ (400 pour un cercle). 
     Cela n'affecte pas les unités angulaires du code NC. Dans le code
    RS274NGC, les mots A-, B- et C- sont toujours exprimés en degrés.

DEFAULT_VELOCITY = 0.0167::
      La vitesse initiale de jog des axes linéaires, en unités par seconde.
    La valeur indiquée ici correspond à une unité par minute. 

DEFAULT_ACCELERATION = 2.0::
      Dans les machines à cinématique non triviale, l'accélération utilisée
    pour _teleop_ jog (espace cartésien), en unités machine par seconde par seconde. 

MAX_VELOCITY = 5.0::
      (((MAX VELOCITY))) Vitesse maximale de déplacement pour les axes,
    exprimée en unités machine par seconde. La valeur indiquée est égale à
    300 unités par minute.

MAX_ACCELERATION = 20.0::
      (((MAX ACCELERATION))) Accélération maximale pour les axes, exprimée
    en unités machine par seconde par seconde.

POSITION_FILE = position.txt::
     Si réglée à une valeur non vide, les positions des axes (joins) sont
    enregistrées dans ce fichier. Cela permet donc de redémarrer avec les
    mêmes coordonnées que lors de l'arrêt, ce qui suppose, que hors
    puissance, la machine ne fera aucun mouvement pendant tout son arrêt.
    C'est utile pour les petites machines sans contact d'origine machine.
    Si vide, les positions ne seront pas enregistrées et commenceront à 0 à
    chaque fois que LinuxCNC démarrera.

NO_FORCE_HOMING = 1::
     LinuxCNC oblige implicitement l'utilisateur à référencer la machine par une
    prise d'origine machine avant de pouvoir lancer un programme ou
    exécuter une commande dans le MDI, seuls les mouvements de Jog sont
    autorisés avant les prises d'origines. Mettre NO_FORCE_HOMING = 1
    permet à l'utilisateur averti de s'affranchir de cette restriction de
    sécurité lors de la phase de mise au point de la machine. 

[WARNING]
_NO_FORCE_HOMING_ mise à 1 permettra à la machine de franchir les
limites logicielles pendant les mouvements ce qui n'est pas souhaitable
pour un fonctionnement normal!

[[sub:Section-AXIS]]
=== Section AXIS_n

(((Section [AXIS_n] du fichier ini)))

Les sections [AXIS_0], [AXIS_1], etc. contiennent les paramètres
généraux des composants individuels du module de contrôle. La
numérotation des sections axis commencent à 0 et vont jusqu'au nombre
d'axes spécifié dans la variable [TRAJ] AXES, moins 1.

Généralement (mais pas toujours):

 - AXIS_0 = X
 - AXIS_1 = Y
 - AXIS_2 = Z
 - AXIS_3 = A
 - AXIS_4 = B
 - AXIS_5 = C
 - AXIS_6 = U
 - AXIS_7 = V
 - AXIS_8 = W

TYPE = LINEAR::
    Type des axes, soit LINEAR, soit ANGULAR.

WRAPPED_ROTARY = 1::
     Lorsque ce paramètre est réglé à 1 pour un axe angulaire
    l'axe se déplace de 0 à 359.999 degrés. Les nombres positifs déplacent
    l'axe dans le sens positif et les nombres négatifs dans le sens négatif.

UNITS = inch::
    (((UNITS))) Ce réglage écrase celui des variables [TRAJ] UNITS si il est
    spécifié. (ex: [TRAJ]LINEAR_UNITS si le TYPE de cet axe est LINEAR,
    [TRAJ]ANGULAR_UNITS si le TYPE de cet axe est ANGULAR)

MAX_VELOCITY = 1.2::
    Vitesse maximum pour cet axe en unités machine par seconde.

MAX_ACCELERATION = 20.0::
     Accélération maximum pour cet axe en unités machine par seconde au
    carré.

BACKLASH = 0.000::
     Valeur de compensation du jeu en unités machine. Peut être utilisée
    pour atténuer de petites déficiences du matériel utilisé pour piloter
    cet axe. Si un backlash est ajouté à un axe et que des moteurs pas à
    pas sont utilisés, la valeur de STEPGEN_MAXACCEL doit être 1.5 à 2
    fois plus grande que celle de MAX_ACCELERATION pour cet axe.

COMP_FILE = file.extension::
     Fichier dans lequel est enregistrée une structure de compensation
    spécifique à cet axe. Le fichier peut être nommé _xscrew.comp_,
    par exemple, pour l'axe X. Les noms de fichiers sont sensibles à la
    casse et peuvent contenir des lettres et/ou des chiffres. Les valeurs
    sont des triplets par ligne séparés par un espace. La première valeur
    est nominale (où elle devrait l'être). Les deuxième et troisième valeurs
    dépendront du réglage de  COMP_FILE_TYPE. Actuellement la
    limite de LinuxCNC est de 256 triplets par axe. Si COMP_FILE est spécifié,
    BACKLASH est ignoré. Les valeurs sont en unités machine.

COMP_FILE_TYPE = 0 ou 1::
     _Si 0:_ Les deuxième et troisième valeurs spécifient
    la position en avant (de combien l'axe est en avance) et
    la position en arrière (de combien l'axe est en retard),
    positions qui correspondent à la position nominale.
     _Si 1:_ Les deuxième et troisième valeurs spécifient l'ajustement avant
    (à quelle distance de la valeur nominale lors d'un déplacement vers l'avant)
    et l'ajustement arrière (à quelle distance de la valeur nominale lors d'un
    déplacement vers l'arrière), positions qui correspondent à la position
    nominale.

    Exemple de triplet avec COMP_FILE_TYPE = 0: 1.00 1.01 0.99
    Exemple de triplet avec COMP_FILE_TYPE = 1: 1.00 0.01 -0.01

MIN_LIMIT = -1000::
    (((MIN LIMIT))) Limite minimale des mouvements de cet axe (limite
    logicielle), en unités machine. Quand cette limite tend à être dépassée,
    le contrôleur arrête le mouvement.

MAX_LIMIT = 1000::
    (((MAX LIMIT))) Limite maximale des mouvements de cet axe (limite
    logicielle), en unités machine. Quand cette limite tend à être dépassée,
    le contrôleur arrête le mouvement.

MIN_FERROR = 0.010::
    (((MIN FERROR))) Valeur indiquant, en unités machine, de combien le 
    mobile peut dévier à très petite vitesse de la position commandée. Si
    MIN_FERROR est plus petit que FERROR, les deux produisent une rampe de
    points de dérive. Vous pouvez imaginer un graphe sur lequel une
    dimension représente la vitesse et l'autre, l'erreur tolérée. Quand la
    vitesse augmente, la quantité d'erreurs de suivi augmente également et
    tend vers la valeur FERROR. 

FERROR = 1.0::
    (((FERROR))) FERROR est le maximum d'erreurs de suivi tolérable, en unités
    machine. Si la différence entre la position commandée et la
    position retournée excède cette valeur, le contrôleur désactive les
    calculs des servomoteurs, positionne toutes les sorties à 0.0 et coupe
    les amplis des moteurs. Si MIN_FERROR est présent dans le fichier .ini,
    une vitesse proportionnelle aux erreurs de suivi est utilisée. Ici, le
    maximum d'erreur de suivi est proportionnel à la vitesse, quand FERROR
    est appliqué à la vitesse rapide définie dans [TRAJ]MAX_VELOCITY et
    proportionnel aux erreurs de suivi pour les petites vitesses. L'erreur
    maximale admissible sera toujours supérieure à MIN_FERROR. Cela permet
    d'éviter que de petites erreurs de suivi sur les axes stationnaires
    arrêtent les mouvements de manière impromptue. Des petites erreurs de
    suivi seront toujours présentes à cause des vibrations, etc. La
    polarité des valeurs de suivi détermine comment les entrées sont
    interprétées et comment les résultats sont appliqués aux sorties. Elles
    peuvent généralement être réglées par tâtonnement car il n'y a que deux
    possibilités. L'utilitaire de calibration peut être utilisé pour les
    ajuster interactivement et vérifier les résultats, de sorte que les
    valeurs puissent être mises dans le fichier INI avec un minimum de
    difficultés. Cet utilitaire est accessible dans Axis depuis le menu
    _Machine_ puis _Calibration_ et dans TkLinuxCNC depuis le menu _Réglages_
    puis _Calibration_.

[[sub:Variables-relatives-aux-origines]]
==== Variables relatives aux prises d'origines

Les paramètres suivants sont relatifs aux prises d'origine, pour plus
d'informations, lire <<sec:Prises-d-origine, le chapitre sur la POM>>.

HOME = 0.0::
     La position à laquelle le joint ira à la fin de la séquence de prise
    d'origine.

HOME_OFFSET = 0.0::
     Position du contact d'origine machine de l'axe ou impulsion d'index,
    en unités machine.

HOME_SEARCH_VEL = 0.0::
    (((HOME SEARCH VEL))) Vitesse du mouvement initial de prise d'origine,
    en unités machine par seconde. Une valeur de zéro suppose que la
    position courante est l'origine machine. Si votre machine n'a pas de
    contact d'origine, laissez cette valeur à zéro.

HOME_LATCH_VEL = 0.0::
     Vitesse du mouvement de dégagement du contact d'origine, en unités
    machine par seconde.

HOME_FINAL_VEL = 0.0::
     Vitesse du mouvement final entre le contact d'origine et la position
    d'origine, en unités machine par seconde. Si cette variable est laissée
    à 0 ou absente, la vitesse de déplacement rapide est utilisée. Doit
    avoir une valeur positive.

HOME_USE_INDEX = NO::
     Si l'encodeur utilisé pour cet axe fournit une impulsion d'index et
    qu'elle est gérée par la carte contrôleur, vous pouvez mettre sur Yes.
    Quand il est sur yes, il aura une incidence sur le type de séquence de
    prise d'origine utilisé.

HOME_IGNORE_LIMITS = NO::
     Certaines machines utilisent un seul et même contact comme limite
    d'axe et origine machine de l'axe. Cette variable devra être
    positionnée sur yes si c'est le cas de votre machine.

HOME_IS_SHARED = <n>::
     Si l'entrée du contact d'origine est partagée par plusieurs axes,
    mettre <n> à 0 pour permettre la POM même si un des contacts partagés
    est déjà attaqué. Le mettre à 1 pour interdire la prise d'origine dans
    ce cas.

HOME_SEQUENCE = <n>::
     Utilisé pour définir l'ordre dans lequel les axes se succéderont lors
    d'une séquence de _POM générale_. *<n>* commence à 0, aucun numéro ne
    peut être sauté. Si cette variable est absente ou à -1, la POM de l'axe
    ne pourra pas être exécutée par la commande _POM générale_. La POM de
    plusieurs axes peut se dérouler simultanément.

VOLATILE_HOME = 0::
      Lorsqu'il est activé (mis à 1), l'origine machine de cette articulation
    sera effacée si la machine est en marche et que l'arrêt d'urgence est activé.
     Ceci est utile si la machine possède des contacts d'origine mais n'a pas
    de retour de position comme une machine à moteur pas à pas de type
    pas/direction.

[[sub:Variables-relatives-aux-servomoteurs]]
==== Variables relatives aux servomoteurs

Les éléments suivants sont pour les systèmes à servomoteurs et à pseudos
servomoteurs. Cette description suppose que les unités en sortie du
composant PID sont des Volts.

DEADBAND = 0.000015::
    (in HAL) Quelle distance est assez proche de la consigne pour considérer le
moteur en position, en unités machine. Cette variable est fréquemment réglée pour
une distance équivalente à 1, 1.5, 2, ou 3 impulsions de comptage du codeur,
mais cela n'a rien d'une règle stricte. Un réglage lâche (large) permet de moins
solliciter le servo au détriment de la précision. Un réglage serré (petit)
permettra d'atteindre une grande précision mais le servo sera plus sollicité.
Est-ce vraiment plus précis si c'est plus incertain ? En règle générale, il est
préférable d'éviter le plus possible de solliciter le servo,  si c'est possible.

Ayez la prudence de ne pas chercher à aller en dessous d'une impulsion de codeur,
sinon vous enverrez votre servo quelque part où il ne sera pas heureux ! Cela
peut arriver entre réglage lent et réglage nerveux et même un réglage impropre
peut provoquer des couinements, des grincements dus aux oscillations provoquées
par ce mauvais réglage. Il est préférable de perdre une ou deux impulsions au
début des réglages, au moins  jusqu'à avoir bien dégrossis les réglages.

Exemple de calcul en unités machine par top de codeur à utiliser pour décider de
la valeur de DEADBAND (bande morte):

*+X pouces / top de codeur =+*
*+1 tour / 1000 top de codeur * 1 top de codeur / 4 top en quadrature * 0.2
pouce / tour =+*
*+0.200 pouce / 4000 top de codeur = 0.000050 pouce / top de codeur.+*

BIAS = 0.000::
     (in HAL) (Parfois appelé _offset_) il est utilisé par hm2-servo et
    quelques autres.
    Le Bias est une valeur constante qui est ajoutée sur la sortie.
    Dans la plupart des cas, elle peut rester à zéro.
    Toutefois, il peut être intéressant pour compenser un décalage de l'ampli
    du servo, ou équilibrer le poids d'un objet se déplaçant verticalement.
    Le bias est mis à zéro quand la boucle PID est désactivée, comme
    tous les autres composants de la sortie.

P = 50::
     (hal) La composante *p* roportionnelle du gain de l'ampli moteur de
    cet axe. Cette valeur
    multiplie l'erreur entre la position commandée et la position actuelle
    en unités machine, elle entre dans le calcul de la tension appliquée à
     l'ampli moteur. Les unités du gain *P*  sont des Volts sur des unités
    machine, par exemple: *+Volt/mm+* si l'unité machine est le millimètre.

I = 0::
      (hal) La composante *i* ntégrale du gain de l'ampli moteur de cet
    axe. Cette valeur multiplie
    l'erreur cumulative entre la position commandée et la position actuelle
    en unités machine, elle entre dans le calcul de la tension appliquée à
     l'ampli moteur. Les unités du gain *I* sont des Volts sur des unités
    machine par seconde, exemple: *+Volt/mm*s+* si l'unité machine est le
    millimètre.

D = 0::
      (hal) La composante *d* érivée du gain de l'ampli moteur de cet axe.
    Cette valeur multiplie la
    différence entre l'erreur courante et les précédentes, elle entre dans
     le calcul de la tension appliquée à l'ampli moteur. Les unités du gain
    *D* sont des Volts sur des unités machine sur des secondes, exemple:
    *+Volt/(mm/s)+* si l'unité machine est le millimètre.

FF0 = 0::
     (hal) Gain à priori (retour vitesse) d'ordre 0. Cette valeur est multipliée
    par la position commandée, elle entre dans le calcul de la tension appliquée
    à l'ampli moteur. Les unités du gain FF0 sont des Volts sur des unités
    machine, exemple: *+Volt/mm+* si l'unité machine est le millimètre.

FF1 = 0::
     (hal) Gain à priori (retour vitesse) de premier ordre. Cette valeur est
    multipliée par l'écart de la position commandée par seconde, elle entre
    dans le calcul de la tension appliquée à l'ampli moteur. Les unités du
    gain FF1 sont des Volts sur des unités machine par seconde, exemple:
    *+Volt/(mm/s)+* si l'unité machine est le millimètre.

FF2 = 0::
     (hal)  Gain à priori (retour vitesse) de second ordre. Cette valeur est
    multipliée par l'écart de la position commandée par seconde au carré,
    elle entre dans le calcul de la tension appliquée à l'ampli moteur. Les
    unités du gain FF2 sont des Volts sur des unités machine par des
    secondes au carré, exemple: *+Volt/mm/s^2^+* si l'unité machine est le
    millimètre.

OUTPUT_SCALE = 1.000::
    
OUTPUT_OFFSET = 0.000::
     (hal)  Ces deux valeurs sont les facteurs d'échelle et offset pour
    la sortie de l'axe à l'amplificateurs moteur.
    La seconde valeur (offset) est soustraite de la
    valeur de sortie calculée (en Volts) puis divisée par la première
    valeur (facteur d'échelle), avant d'être écrite dans le convertisseur
    D/A. Les unités du facteur d'échelle sont des Volts réels par Volts en
    sortie de DAC. Les unités de la valeur d'offset sont en Volts. Ces
    valeurs peuvent être utilisées pour linéariser un DAC.
     Plus précisément, quand les sorties sont écrites, LinuxCNC converti d'abord
    les unités quasi-SI des sorties concernées en valeurs brutes, exemple:
    Volts pour un amplificateur DAC. Cette mise à l'échelle ressemble à
    cela:

*+raw = output-offset/scale+*

la valeur d'échelle peut être obtenue par analyse des unités, exemple: les unités
sont [unités SI en sortie]/[unités de l'actuateur]. Par exemple, sur
une machine sur laquelle une tension de consigne de l'ampli de 1 Volt
donne une vitesse de 250 mm/sec :
    
*+amplifier [volts] = (output[mm/s] - offset[mm/s]) / 250mm/(sec/Volt)+*
   
Notez que les unités d'offset sont en unités machine, exemple:
mm/sec et qu'elles sont déjà soustraites depuis la sonde de lecture. La
valeur de cet offset est obtenue en prenant la valeur de votre sortie
qui donne 0,0 sur la sortie de l'actuateur. Si le DAC est linéarisé,
cet offset est normalement de 0.0.

L'échelle et l'offset peuvent être utilisés pour linéariser les DAC,
d'où des valeurs qui reflètent les effets combinés du gain de l'ampli,
de la non linéarité du DAC, des unités du DAC, etc. Pour ce faire,
suivez cette procédure:

- Construire un tableau de calibrage pour la sortie, piloter le DAC
   avec la tension souhaitée et mesurer le résultat. Voir le tableau
   ci-dessous pour un exemple de mesures de tension.
- Par la méthode des moindres carrés, obtenir les coefficients *a*,*b*
   tels que: *+mesure = a*raw+b+*
- Noter que nous voulons des sorties brutes de sorte que nos résultats
   mesurés soient identiques à la sortie commandée. Ce qui signifie:
- *+cmd = a*raw+b+*
- *+raw = (cmd-b)/a+*
-  En conséquence, les coefficients *a* et *b* d'ajustement linéaire
   peuvent être directement utilisés comme valeurs d'échelle et 
   d'offset pour le contrôleur. 

.Mesure des tensions de sortie[[cap:Mesure des tensions de sortie]]

[width="90%", options="header"]
|========================================
|Brutes (Raw) | Mesurées
|-10 | -9.93
|-9 | -8.83
|0 | -0.03
|1 | 0.96
|9 | 9.87
|10 | 10.87
|========================================

MAX_OUTPUT = 10::
     (hal) La valeur maximale pour la sortie de la compensation PID
    pouvant être
    envoyée sur l'ampli moteur, en Volts. La valeur calculée de la sortie
    sera fixée à cette valeur limite. La limite est appliquée avant la mise
    à l'échelle de la sortie en unités brutes. La valeur est appliquée de
    manière symétrique aux deux côtés, le positif et le négatif.

INPUT_SCALE = 20000::
    (((INPUT SCALE))) (hal) Spécifie le nombre d'impulsions qui
    correspond à un mouvement de une unité machine telle que fixée dans la
    section TRAJ.
    Pour un axe linéaire, une unité machine sera égale à la valeur de LINEAR_UNITS.
    Pour un axe angulaire, une unité machine sera égale à la valeur de ANGULAR_UNITS.
    Un second chiffre, si spécifié, sera ignoré.
    Par exemple, sur un codeur de 2000 impulsions par tour(((codeur))), un
    réducteur de 10 tours/pouce et des unités demandées en pouces, nous avons:

*+INPUT_SCALE = 2000 top/tour * 10 tour/pouce = 20000 top/pouce+*

[[sub:Variables-relatives-aux-moteurs-pas-a-pas]]
==== Variables relatives aux moteurs pas à pas

SCALE = 4000::
    (((INPUT SCALE))) (hal) Spécifie le nombre d'impulsions qui correspond à un
    mouvement d'une unité machine comme indiqué dans la section [TRAJ].
    Pour les systèmes à moteurs pas à pas, c'est
    le nombre d'impulsions de pas nécessaires pour avancer d'une unité machine.
    Pour un axe linéaire, une unité machine sera égale à la valeur de LINEAR_UNITS.
    Pour un axe angulaire, une unité machine sera égale à la valeur de ANGULAR_UNITS.
    Pour les systèmes à servomoteurs, c'est le nombre d'impulsions
    de retour signifiant que le mobile a avancé d'une unité machine.
    Un second nombre, si spécifié, sera ignoré.
    Par exemple, un pas moteur de 1.8 degré, en mode demi-pas, avec une
    réduction de 10 tours/pouce et des unités souhaitées en pouces, nous
    avons:

*+scale = 2 pas/1.8 degrés * 360 degrés/tour * 10 tour/pouce = 4000 pas/pouce+*

(D'anciens fichiers .ini et .hal utilisaient INPUT_SCALE pour cette valeur.)

STEPGEN_MAXACCEL = 21.0::
     (hal) Limite d'accélération pour le générateur de pas. Elle doit être
    1% à 10% supérieure à celle de l'axe MAX_ACCELERATION. Cette valeur améliore
    les réglages de la _boucle de position_ de stepgen. Si une correction
    de jeu a été appliquée sur un axe, alors STEPGEN_MAXACCEL doit
    être 1,5 à 2 fois plus grande que MAX_ACCELERATION.

STEPGEN_MAXVEL = 1.4::
     (hal) Les anciens fichiers de configuration avaient également une
    limite de vitesse du générateur de pas. Si spécifiée, elle doit aussi être
    1% à 10% supérieure à celle de l'axe MAX_VELOCITY. Des tests ultérieurs ont
    montré que l'utilisation de STEPGEN_MAXVEL n'améliore pas le réglage de
    la boucle de position de stepgen.

[[sub:Section-LINUXCNCIO]]
=== Section LINUXCNCIO

(((Section [LINUXCNCIO] du fichier ini)))

CYCLE_TIME = 0.100::
     La période en secondes, à laquelle LINUXCNCIO va tourner. La mettre à 0.0
    ou à une valeur négative fera que LINUXCNCIO tournera en permanence. Il est
    préférable de ne pas modifier cette valeur.

TOOL_TABLE = tool.tbl::
     Ce fichier contient les informations des outils, décrites dans
    le Manuel de l'utilisateur.

TOOL_CHANGE_POSITION = 0 0 2::
     Quand trois digits sont utilisés, spécifie la position XYZ ou le
    mobile sera déplacé pour le changement d'outil.
    Si six digits sont utilisés, spécifie l'emplacement ou sera envoyé
    le mobile pour réaliser le changement d'outil sur une machine de type XYZABC et
    de même, sur une machine de type XYZABCUVW lorsque 9 digits sont utilisés.
    Les variables relatives à la position du changement d'outil peuvent être
    combinées, par exemple; en combinant TOOL_CHANGE_POSITION avec
    TOOL_CHANGE_QUILL_UP il est possible de déplacer d'abord Z puis X et Y.

TOOL_CHANGE_WITH_SPINDLE_ON = 1::
     Avec cette valeur à 1, la broche reste en marche pendant le changement
    d'outil. Particulièrement utile sur les tours.

TOOL_CHANGE_QUILL_UP = 1::
     Avec cette valeur à 1, l'axe Z sera déplacé sur son origine machine
    avant le changement d'outil. C'est l'équivalent d'un G0 G53 Z0.

TOOL_CHANGE_AT_G30 = 1::
     Avec cette valeur à 1, le mobile sera envoyé sur un point de référence
    prédéfini par G30 dans les paramètres 5181-5186. Pour plus de détails
    sur les paramètres de G30, voir le chapitre relatif au G-code dans le
    Manuel de l'utilisateur.

RANDOM_TOOLCHANGER = 1::
     C'est pour des machines qui ne peuvent pas placer l'outil dans la poche il vient.
    Par exemple, les machines qui change l'outil dans la poche active avec l'outil dans la broche.


