= Les bases de HAL

== Commandes de Hal

Des informations plus détaillées peuvent être trouvées dans la man
page en tapant «man halcmd» dans une console. Pour voir la
configuration de HAL ainsi que le status de ses pins et paramétres
utiliser la fenêtre HAL Configuration dans le menu «Machine» d'AXIS.
Pour visualiser le status des pins, ouvrir l'onglet «Watch» puis
cliquer dans l'arborescence sur les pins qui doivent être visualisées
dans la fenêtre watch.

.Fenêtre de configuration de HAL

image::images/HAL_Configuration.png[]

=== loadrt

La commande «loadrt» charge un composant temps réel de HAL. Les
composants temps réel doivent être ajoutés au thread temps réel pour
être fonctionnels. Il n'est pas possible de charger un composant de
l'espace utilisateur dans l'espace temps réel.

Syntaxe et exemple:

+loadrt <component> <options>+ 
+loadrt mux4 count=1+ 

=== addf

La commande «addf» ajoute une fonction à un thread temps réel. Si
l'assistant StepConf a été utilisé pour créer la configuration, deux
threads ont été créés.

 - base-thread (le thread haute vitesse) ce thread prends en main les
   items nécessitant une réponse très rapide comme la génération
   d'impulsions, la lecture et l'écriture sur le port parallèle.
 - servo-thread (le thread basse vitesse) ce thread prends en main les
   items n'étant pas influencés par la vitesse comme le contrôleur de
   mouvement, l'API Classic Ladder et les commandes manuelles.

Syntaxe et exemple:

+addf <component> <thread>+ 
+addf mux4 servo-thread+ 

=== loadusr

La commande «loadusr» charge un composant de HAL de l'espace
utilisateur. Les programmes de l'espace utilisateur ont leur propre
process séparé qui optionellement communique avec les autres composants
de HAL via leurs pins et paramètres. Il n'est pas possible de charger
un composant temps réel dans l'espace utilisateur.

Les drapeaux peuvent être un ou plusieurs parmis les suivants:

-W::
     pour attendre que le composant soit prêt. Le composant est supposé
    avoir le même nom que le premier argument de la commande.

-Wn <nom>::
    pour attendre un composant, qui porte le nom donné sous la forme <nom>.

-w::
    pour attendre la fin du programme

-i::
    pour ignorer la valeur retournée par le programme (avec -w) 

Syntaxe et exemple:

+loadusr <component> <options>+ 
+loadusr halui+ 
+loadusr -Wn spindle gs2_vfd -n spindle+ 

     En anglais ça donne «loadusr wait for name spindle component gs2_vfd name spindle». 
     Le -n spindle est une partie du composant gs2_vfd et non de la commande loadusr. 

=== net

La commande «net» crée une «connection» entre un signal et une ou
plusieurs pins. Les indicateurs de direction `<=` et `=>` sont seulement
des aides à la lecture, ils n'ont pas d'autre utilité.

Syntaxe et exemple:

+net <signal-name> <pin-name> <opt-direction> <opt-pin-name>+ 
+net both-home-y <= parport.0.pin-11-in+ 

Chaque signal ne peut avoir qu'une seule source (une seule pin de HAL
«out») et autant de «lecteurs» (des pins de HAL «in») que souhaité.
Dans la colonne Dir de la fenêtre de configuration de HAL il est
possible de voir quelles pins sont «in» et quelles pins sont «out».

Pour faire celà en une ligne:

-----------------------------------------------------------
     signal    source            destination          destination 
net xStep stepgen.0.out => parport.0.pin-02-out parport.0.pin-08-out 
-----------------------------------------------------------

Ou pour le faire en plusieurs lignes, utiliser simplement le signal
avec les lecteurs des lignes suivantes:

+net xStep <= stepgen.0.out => parport.0.pin-02-out+ 

Les pins appelées I/O pins comme «index-enable», ne suivent pas cette règle. 

=== setp

La commande `setp` ajuste la valeur d'une pin ou d'un paramètre. Les
valeurs valides dépendront du type de la pin ou du paramètre.

 - bit = true ou 1 et false ou 0 (True, TRUE, true sont toutes valides)
 - float = un flottant sur 32 bits, avec approximativement 24 bits de
   résolution et au plus 200 bits d'étendue dynamique.
 - s32 = un nombre entier compris entre -2147483648 et 2147483647
 - u32 = un nombre entier compris entre 0 et 4294967295

Pour des informations sur les flottants voir ici (en anglais):

http://en.wikipedia.org/wiki/Floating_point[http://en.wikipedia.org/wiki/Floating_point]

Les paramètres peuvent être positionnés avant utilisation ou pendant
l'utilisation, toutefois certains composants ont des paramètres qui
doivent être positionnés avant utilisation. Il n'est pas possible
d'utiliser `setp` sur une pin connectée à un signal.

Syntaxe et exemple:

+setp <pin/parameter-name> <value>+ 
+setp parport.0.pin-08-out TRUE+ 

=== Quatre commandes obsolètes

==== linksp

The command `linksp` creates a «connection» between a signal and one pin. 

Syntaxe et exemple:

+unlinkp <pin-name>+ 
+unlinkp parport.0.pin-02-out+ 

La commande `linksp` a été incluse dans la commande `net`.

==== linkps

The command "linkps" creates a "connection" between one pin and one
signal. It is the same as linksp but the arguments are reversed.

Syntaxe et exemple:

+linksp <signal-name> <pin-name>+ 
+linksp X-step parport.0.pin-02-out+ 

La commande "linkps" a été incluse dans la commande "net".

==== unlinkp

The command "unlinkp" unlinks a pin from the connected signal. If no
signal was connected to the pin prior running the command, nothing
happens.

Syntaxe et exemple:

+linkps <pin-name> <signal-name>+ 
+linkps parport.0.pin-02-out X-Step+ 

==== newsig

the command "newsig" creates a new HAL signal by the name <signame>
and the data type of <type>. Type must be "bit", "s32", "u32" or
"float". Error if <signame> already exists.

Syntaxe et exemple:

+newsig <signame> <type>+ 
+newsig Xstep bit+ 

D'autres informations peuvent être trouvées dans le manuel de HAL ou
la man page de <<halrun>>.

== Fichiers Hal

Si l'assistant StepConf a été utilisé pour générer la configuration
trois fichiers HAL ont dû être créés dans le répertoire de la
configuration.

 - ma-fraiseuse.hal (si ne nom de la config est nomée "ma-fraiseuse") Ce
   fichier est chargé en premier, il ne doit pas être modifié sous peine
   de ne plus pouvoir l'utiliser avec l'assistant StepConf.
 - custom.hal Ce fichier est le deuxième à être chargé et il l'est avant
   l'interface utilisateur graphique (GUI). C'est dans ce fichier que ce
   trouvent les commandes personnalisées de l'utilisateur devant être
   chargées avant la GUI. 
 - custom_postgui.hal Ce fichier est chargé après la GUI. C'est dans ce
   fichier que se trouvent les commandes personnalisées de l'utilisateur
   devant être chargées après la GUI. Toutes les commandes relatives aux
   widgets de pyVCP doivent être placées ici. 

== HAL Components

Two parameters are automatically added to each HAL component when it
is created. These parameters allow you to scope the execution time of a
component.

+.time+(((time))) 
+.tmax+(((tmax))) 

Time is the number of CPU cycles it took to execute the function.

Tmax is the maximum number of CPU cycles it took to execute the
function. Tmax is a read/write parameter so the user can set it to 0 to
get rid of the first time initialization on the function's execution
time.

== Composants de logiques combinatoire

Hal contient plusieurs composants logiques temps réel. Les composants
logiques suivent une tables de vérité montrant les états logiques des
sorties en fonction de l'état des entrées. Typiquement, la manipulation
des bits d'entrée détermine l'état électrique des sorties selon la
table de vérité des portes.

=== and2

Le composant "and2" est une porte "and" à deux entrées. Sa table de
vérité montre la sortie pour chaque combinaison des entrées.

Syntaxe

+and2 [count=N] or [names=name1[,name2...]]+ 

Fonctions

+and2.n+ 

Pins

+and2.N.in0 (bit, in)+ 
+and2.N.in1 (bit, in)+ 
+and2.N.out (bit, out)+ 

Table de vérité

[width="90%", options="header"]
|========================================
|in0   | in1   | out
|False | False | False
|True  | False | False
|False | True  | False
|True  | True  | True
|========================================

=== not

Le composant «not» est un simple inverseur d'état.

Syntaxe

+not [count=n] or [names=name1[,name2...]]+ 

Fonctions

+not.all+ 
+not.n+ 

Pins

+not.n.in (bit, in)+ 
+not.n.out (bit, out)+ 

Table de vérité

[width="90%", options="header"]
|========================================
|in    | out
|True  | False
|False | True
|========================================

=== or2

Le composant "or2" est une porte OR à deux entrées.

Syntaxe

+or2[count=n] or [names=name1[,name2...]]+ 

Functions

+or2.n+ 

Pins

+or2.n.in0 (bit, in)+ 
+or2.n.in1 (bit, in)+ 
+or2.n.out (bit, out)+ 

Table de vérité

[width="90%", options="header"]
|========================================
|in0   | in1   | out
|True  | False | True
|True  | True  | True
|False | True  | True
|False | False | False
|========================================

=== xor2

Le composant "xor2" est une porte XOR à deux entrées (OU exclusif).

Syntaxe

+xor2[count=n] or [names=name1[,name2...]]+ 

Fonctions

+xor2.n+ 

Pins

+xor2.n.in0 (bit, in)+ 
+xor2.n.in1 (bit, in)+ 
+xor2.n.out (bit, out)+ 

Table de vérité

[width="90%", options="header"]
|========================================
|in0   | in1   | out
|True  | False | True
|True  | True  | False
|False | True  | True
|False | False | False
|========================================

=== Exemples de logique combinatoire

Un exemple de connection avec un "and2", deux entrées vers une sortie.

+loadrt and2 count=1+ 
+addf and2.0 servo-thread+ 
+net my-sigin1 and2.0.in0 <= parport.0.pin-11-in+ 
+net my-sigin2 and2.0.in1 <= parport.0.pin-12-in+ 
+net both-on parport.0.pin-14-out <= and2.0.out+ 

Dans cet exemple un and2 est chargé dans l'espace temps réel, puis
ajouté à servo thread. Ensuite la broche d'entrée 11 du port parallèle
est connectée à l'entrée in0 de la porte. Puis la broche d'entrée 12 du
port est connectée à l'entrée in1 de la porte. Enfin la sortie
and2.0.out de la porte est connectée à la broche de sortie 14 du port
parallèle. Ainsi en suivant la table de vérité du and2, si les broches
11 et 12 du port sont à 1, alors sa sortie 14 est à 1 aussi.

== Conversion Components

=== weighted_sum

The weighted_sum converts a group of bits to an integer. The
conversion is the sum of the "weights" of the bits that are on plus any
offset. This is similar to a binary coded decimal but with more
options. The "hold" bit stops processing the input changes so the "sum"
will not change.

The following syntax is used to load the weighted_sum component.

+loadrt weighted_sum wsum_sizes=size[,size,...]+ 

Creates weighted sum groups each with the given number of input bits
(size).

To update the weighted_sum you need to attach process_wsums to a thread.

+addf process_wsums servo-thread+ 

This updates the weighted_sum component.

In the following example clipped from the HAL Configuration window in
Axis the bits "0" and "2" are true and there is no offset. The "weight"
of 0 is 1 and the "weight" of 2 is 4 so the sum is 5.

.weighted_sum[[fig:weighted_sum]]
+Component Pins:+ 
+Owner   Type  Dir         Value  Name+ 
+    10  bit   In           TRUE  wsum.0.bit.0.in+ 
+    10  s32   I/O             1  wsum.0.bit.0.weight+ 
+    10  bit   In          FALSE  wsum.0.bit.1.in+ 
+    10  s32   I/O             2  wsum.0.bit.1.weight+ 
+    10  bit   In           TRUE  wsum.0.bit.2.in+ 
+    10  s32   I/O             4  wsum.0.bit.2.weight+ 
+    10  bit   In          FALSE  wsum.0.bit.3.in+ 
+    10  s32   I/O             8  wsum.0.bit.3.weight+ 
+    10  bit   In          FALSE  wsum.0.hold+ 
+    10  s32   I/O             0  wsum.0.offset+ 
+    10  s32   Out             5  wsum.0.sum+ 


