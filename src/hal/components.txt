= HAL Components [[cha:HAL-Components]]

== Commands and Userspace Components [[sec:Commands-and-Userspace-Components]]

Some of these will have expanded descriptions from the man pages. Some
will have limited descriptions. All of the components have man pages.
From this list you know what components exist and can use man n name to
get additional information. For example in a terminal window type

    man 1 axis 

to view the information in the man page.

 - = AXIS Remote Interface
 - = AXIS EMC (The Enhanced Machine Controller) Graphical User Interface
 -  = A program for loading a Xilinx Bitfile program into the FPGA of an
   Anything I/O board from Mesa
 - = Build, compile and install EMC HAL components
 - = EMC (The Enhanced Machine Controller)
 -  = control HAL pins with any Linux input device, including USB HID
   devices
 - = manipulate the Enhanced Machine Controller HAL from the command line
 - = observe HAL pins, signals, and parameters
 - = manipulate the Enhanced Machine Controller HAL from the command line
 - = sample data from HAL in realtime
 - = stream file data into HAL in real time
 - = observe HAL pins and command EMC through NML
 - = accepts NML I/O commands, interacts with HAL in userspace
 - = accepts NML I/O commands, interacts with HAL in userspace
 - = Virtual Control Panel for EMC2

== Realtime Components [[sec:Realtime-Components]]

Some of these will have expanded descriptions from the man pages. Some
will have limited descriptions. All of the components have man pages.
From this list you know what components exist and can use man n name to
get additional information in a terminal window.

=== abs (((abs)))

Compute the absolute value and sign of the input signal

===== Loading

    loadrt abs [count=N|names=name1[,name2...]]

===== Functions

    addf abs.N|name thread-name

===== Pins

    abs.N.in (float in) Input value
    abs.N.out (float out) Output Value, always positive
    abs.N.sign (bit out) Sign of Input, false = positive, true = negative

The first abs loaded will be abs.0 and each one after that the "N"
number will increment.

=== and2 (((and2)))

Two-input AND gate. For out to be true both inputs must be true

===== Loading

    loadrt and2 [count=N|names=name1[,name2...]]

===== Functions

    addf and2.N|name thread-name

===== Pins

    and2.N.in0 (bit in) Input 0
    and2.N.in1 (bit in) Input 1
    and2.N.out (bit out) Output

=== at_pid (((at_pid)))

proportional/integral/derivative controller with auto tuning

=== axis (((axis)))

accepts NML motion commands, interacts with HAL in realtime

=== biquad (((biquad)))

Biquad IIR filter

=== bldc_hall3 (((bldc_hall3)))

3-wire Bipolar trapezoidal commutation BLDC motor driver using Hall
sensors

=== blend (((blend)))

Perform linear interpolation between two values

===== Loading

    loadrt blend [count=N|names=name1[,name2...]]

===== Functions

    addf blend.N|name thread-name

===== Pins

    blend.N.in1 (float in) First input.
    blend.N.in2 (float in) Second input.
    blend.N.select (float in) Select input.
    blend.N.out (float out) Output value.

===== Parameters

    blend.N.open (bit r/w)

===== Description

If select is equal to 0.0 output is equal to in1.

If select is equal to 1.0, the output is equal to in2.

For select values between 0.0 and 1.0, the output changes linearly
from in1 to in2.

If blend.N.open is true, select values outside the range 0.0 to 1.0
give values outside the range in1 to in2. If false, outputs are clamped
to the the range in1 to in2

=== charge_pump (((charge_pump)))

Create a square-wave for the "charge pump" input of some controller
boards

===== Loading

    loadrt charge_pump

===== Functions

    addf charge-pump

===== Pins

    charge-pump.out (bit out)
    charge-pump.enable (bit in) default = TRUE

===== Description

Outputs a square wave if enable is TRUE or unconnected, low if enable
is FALSE

=== clarke2 (((clarke2)))

Two input version of Clarke transform

===== Loading

    loadrt clarke2 [count=N|names=name1[,name2...]]

===== Functions

    addf clarke2.N | name

===== Pins

    clarke2.N.a (float in) phase a input
    clarke2.N.b (float in) phase b input
    clarke2.N.x (float out) cartesian components of output
    clarke2.N.y (float out) cartesian components of output

===== Description

The Clarke transform can be used to translate a vector quantity from a
three phase system (three components 120 degrees apart) to a two phase
Cartesian system.

clarke2 implements a special case of the Clarke transform, which only
needs two of the three input phases. In a three wire three phase
system, the sum of the three phase currents or voltages must always be
zero. As a result only two of the three are needed to completely define
the current or voltage. clarke2 assumes that the sum is zero, so it
only uses phases A and B of the input. Since the H (homopolar) output
will always be zero in this case, it is not generated.

=== clarke3 (((clarke3)))

Clarke (3 phase to cartesian) transform

===== Loading

    loadrt clarke3 [count=N|names=name1[,name2...]]

===== Functions

    addf clarke3.N | name

===== Pins

    clarke3.N.a (float in) three phase input vector
    clarke3.N.b (float in) three phase input vector
    clarke3.N.c (float in) three phase input vector
    clarke3.N.x (float out) cartesian components of output
    clarke3.N.y (float out) cartesian components of output
    clarke3.N.h (float out) homopolar component of output

===== Description

The Clarke transform can be used to translate a vector quantity from a
three phase system (three components 120 degrees apart) to a two phase
Cartesian system (plus a homopolar component if the three phases don't
sum to zero).

clarke3 implements the general case of the transform, using all three
phases. If the three phases are known to sum to zero, see clarke2 for a
simpler version.

=== clarkeinv (((clarkeinv)))

Inverse Clarke transform

===== Loading

    loadrt clarkeinv [count=N|names=name1[,name2...]]

===== Functions

    addf clarkeinv.N | name

===== Pins

    clarkeinv.N.x (float in) cartesian components of input
    clarkeinv.N.y (float in) cartesian components of input
    clarkeinv.N.h (float in) homopolar component of input (usually zero)
    clarkeinv.N.a (float out) three phase output vector
    clarkeinv.N.b (float out) three phase output vector
    clarkeinv.N.c (float out) three phase output vector

===== Parameters
.

===== Description

The inverse Clarke transform can be used to translate a vector
quantity from Cartesian coordinate system to a three phase system
(three components 120 degrees apart).

=== classicladder (((classicladder)))

Realtime software plc based on ladder logic

=== comp (((comp)))

Two input comparator with hysteresis

=== constant (((constant)))

Use a parameter to set the value of a pin

=== conv_bit_s32 (((conv_bit_s32)))

Convert a value from bit to s32

=== conv_bit_u32 (((conv_bit_u32)))

Convert a value from bit to u32

=== conv_float_s32 (((conv_float_s32)))

Convert a value from float to s32

=== conv_float_u32 (((conv_float_u32)))

Convert a value from float to u32

=== conv_s32_bit (((conv_s32_bit)))

Convert a value from s32 to bit

=== conv_s32_float (((conv_s32_float)))

Convert a value from u32 to bit

=== conv_s32_u32 (((conv_s32_u32)))

Convert a value from s32 to u32

=== conv_u32_bit (((conv_u32_bit)))

Convert a value from u32 to bit

=== conv_u32_float (((conv_u32_float)))

Convert a value from u32 to float

=== conv_u32_s32 (((conv_u32_s32)))

Convert a value from u32 to s32

=== counter (((counter)))

counts input pulses (deprecated)

=== ddt (((ddt)))

Compute the derivative of the input function

=== deadzone (((deadzone)))

Return the center if within the threshold

=== debounce (((debounce)))

filter noisy digital inputs, for more information see  <<sec:Debounce>>

=== edge (((edge)))

Edge detector

=== encoder (((encoder)))

software counting of quadrature encoder signals, for more information
see  <<sec:Encoder>>

=== encoder_ratio (((encoder_ratio)))

an electronic gear to synchronize two axes

=== estop_latch (((estop_latch)))

ESTOP latch

=== feedcomp (((feedcomp)))

Multiply the input by the ratio of current velocity to the feed rate

=== flipflop (((flipflop)))

D type flip-flop

=== freqgen (((freqgen)))

software step pulse generation

=== gantrykins

A kinematics module that maps one axis to multiple joints

=== gearchange (((gearchange)))

Select from one two speed ranges

=== genhexkins (((genhexkins)))

Gives six degrees of freedom in position and orientation (XYZABC). The
location of the motors is defined at compile time.

=== genserkins

Kinematics that can model a general serial-link manipulator with up to
6 angular joints.

=== hm2_7i43 (((hm2_7i43)))

HAL driver for the Mesa Electronics 7i43 EPP Anything IO board with
HostMot2

=== hm2_pci (((hm2_pci)))

HAL driver for the Mesa Electronics 5i20, 5i22, 5i23, 4i65, and 4i68
Anything IO boards, with HostMot2 firmware

=== hostmot2 (((hostmot2)))

HAL driver for the Mesa Electronics HostMot2 firmware

=== hypot (((hypot)))

Three-input hypotenuse (Euclidean distance) calculator

=== ilowpass (((ilowpass)))

Low-pass filter with integer inputs and outputs

=== integ (((integ)))

Integrator

=== invert (((invert)))

Compute the inverse of the input signal

=== joyhandle (((joyhandle)))

sets nonlinear joypad movements, deadbands and scales

=== kins (((kins)))

kinematics definitions for emc2

=== knob2float (((knob2float)))

Convert counts (probably from an encoder) to a float value

=== limit1 (((limit1)))

Limit the output signal to fall between min and max

=== limit2 (((limit2)))

Limit the output signal to fall between min and max

=== limit3 (((limit3)))

Limit the output signal to fall between min and max

=== logic (((logic)))

Experimental general logic function component

=== lowpass (((lowpass)))

Low-pass filter

=== lut5 (((lut5)))

Arbitrary 5-input logic function based on a look-up table

=== maj3 (((maj3)))

Compute the majority of 3 inputs

=== match8 (((match8)))

8-bit binary match detector

=== maxkins (((maxkins)))

Kinematics for a tabletop 5 axis mill named "max" with tilting head (B
axis) and horizintal rotary mounted to the table (C axis). Provides UVW
motion in the rotated coordinate system. The source file, maxkins.c,
may be a useful starting point for other 5-axis systems.

=== minmax (((minmax)))

Track the minimum and maximum values of the input to the outputs

=== motion (((motion)))

accepts NML motion commands, interacts with HAL in realtime

=== mult2 (((mult2)))

Product of two inputs

=== mux2 (((mux2)))

Select from one of two input values

=== mux4 (((mux4)))

Select from one of four input values

=== mux8 (((mux8)))

Select from one of eight input values

=== near (((near)))

Determine whether two values are roughly equal

=== not (((not)))

Inverter

=== offset (((offset)))

Adds an offset to an input, and subtracts it from the feedback value

=== oneshot (((oneshot)))

one-shot pulse generator

=== or2 (((or2)))

Two-input OR gate

=== pid (((pid)))

proportional/integral/derivative controller, for more information see 
<<sec:PID>>

=== pluto_servo (((pluto_servo)))

Hardware driver and firmware for the Pluto-P parallel-port FPGA, for
use with servos

=== pluto_step (((pluto_step)))

Hardware driver and firmware for the Pluto-P parallel-port FPGA, for
use with steppers

=== pwmgen (((pwmgen)))

software PWM/PDM generation, for more information see  <<sec:PWMgen>>

=== rotatekins (((rotatekins)))

The X and Y axes are rotated 45 degrees compared to the joints 0 and 1.

=== sample_hold (((sample_hold)))

Sample and Hold

=== sampler (((sampler)))

sample data from HAL in real time

=== scale (((scale)))

applies a scale and offset to its input

=== scarakins (((scarakins)))

kinematics for SCARA-type robots

=== select8 (((select8)))

8-bit binary match detector

=== serport (((serport)))

Hardware driver for the digital I/O bits of the 8250 and 16550 serial
port

=== siggen (((siggen)))

signal generator, for more information see  <<sec:Siggen>>

=== sim_encoder (((sim_encoder)))

simulated quadrature encoder, for more information see 
<<sec:Simulated-Encoder>>

=== sphereprobe (((sphereprobe)))

Probe a pretend hemisphere

=== stepgen (((stepgen)))

software step pulse generation, for more information see 
<<sec:Stepgen>>

=== steptest (((steptest)))

Used by Stepconf to allow testing of acceleration and velocity values
for an axis

=== streamer (((streamer)))

stream file data into HAL in real time

=== sum2 (((sum2)))

Sum of two inputs (each with a gain) and an offset

=== supply (((supply)))

set output pins with values from parameters (deprecated)

=== thc

Torch Height Control using a Mesa THC card.

=== threads (((threads)))

creates hard realtime HAL threads

=== threadtest (((threadtest)))

component for testing thread behavior

=== timedelay (((timedelay)))

The equivalent of a time-delay relay

=== timedelta (((timedelta)))

component that measures thread scheduling timing behavior

=== toggle (((toggle)))

push-on, push-off from momentary pushbuttons

=== toggle2nist (((toggle2nist)))

toggle button to nist logic

=== tripodkins (((tripodkins)))

The joints represent the distance of the controlled point from three
predefined locations (the motors), giving three degrees of freedom in
position (XYZ)

=== tristate_bit (((tristate_bit)))

Place a signal on an I/O pin only when enabled, similar to a tristate
buffer in electronics

=== tristate_float (((tristate_float)))

Place a signal on an I/O pin only when enabled, similar to a tristate
buffer in electronics

=== trivkins (((trivkins)))

There is a 1:1 correspondence between joints and axes. Most standard
milling machines and lathes use the trivial kinematics module.

=== updown (((updown)))

Counts up or down, with optional limits and wraparound behavior

=== wcomp (((wcomp)))

Window comparator

=== weighted_sum (((weighted_sum)))

convert a group of bits to an integer

=== xor2 (((xor2)))

Two-input XOR (exclusive OR) gate

===== Loading
.

===== Functions
.

===== Pins
.

===== Parameters
.

===== Description
.

